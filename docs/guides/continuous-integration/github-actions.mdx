---
title: GitHub Actions
---

:::info

## <Icon name="graduation-cap" /> What you'll learn

- How to run Cypress tests with GitHub Actions as part of a CI/CD pipeline
- How to parallelize Cypress test runs within GitHub Actions
- How to cache build artifacts between installation jobs and worker jobs
- Best practices to deduplicate and parallelize E2E tests in GitHub Action _without_ Cypress Cloud

:::

<DocsVideo src="https://youtube.com/embed/videoseries?list=PL8GlT7H3xOcLJMIPhxlZ8W9kgbeMqW7cH" />

:::info

## GitHub Actions + Cypress Screencasts

1. [What is Continuous Integration?](https://youtu.be/USX6AntcPyg)
2. [Actions & Workflows](https://youtu.be/N0TOFWy1Xvg)
3. [Example App Overview](https://youtu.be/zGrAhZkCoUE)
4. [Understanding how to configure a workflow](https://youtu.be/vVr7DXDdUks)
5. [Running Tests in GitHub Actions CI/CD Workflow](https://youtu.be/23ZGSrmbV_4)
6. [Debugging Test Failures in CI](https://youtu.be/Oqq-_QZWzhg)
7. [Running Tests in Parallel](https://youtu.be/96Yn_IiQUJI)

:::

GitHub offers developers [Actions](https://github.com/features/actions) that
provide a way to **automate, customize, and execute your software development
workflows** within your GitHub repository. Detailed documentation is available
in the [GitHub Action Documentation](https://docs.github.com/en/actions).

## Cypress GitHub Action

<DocsVideo src="https://youtube.com/embed/N0TOFWy1Xvg" />

Workflows can be packaged and shared as
[GitHub Actions](https://github.com/features/actions). GitHub maintains many,
such as the [checkout](https://github.com/marketplace/actions/checkout) and
[Upload/Download Artifact Actions](https://docs.github.com/en/actions/guides/storing-workflow-data-as-artifacts)
actions used below.

The official
[Cypress GitHub Action](https://github.com/marketplace/actions/cypress-io) is
maintained by Cypress and our community to help ease the setup of Cypress in a
GitHub Action. The action provides dependency installation (via npm, yarn, or
pnpm), built-in caching of Node dependencies, and additional configuration
options for advanced workflows.

### Version Number Selection

:::info

<strong>GitHub Action Version Number</strong>

We recommend binding to the action's latest major version by specifying `v5`
when using the action.

:::

For Example:

```yaml
jobs:
  cypress-run:
    steps:
      uses: cypress-io/github-action@v5
```

Alternatively, as a mitigation strategy for unforeseen breaks, bind to a
specific
[release version tag](https://github.com/cypress-io/github-action/releases), for
example `cypress-io/github-action@v5.1.0`. Read the
[Cypress GitHub Action documentation](https://github.com/cypress-io/github-action#action-version)
for more information.

## Basic Setup

<DocsVideo src="https://youtube.com/embed/vVr7DXDdUks" />

The example below is a basic CI setup and job using the
[Cypress GitHub Action](https://github.com/marketplace/actions/cypress-io) to
run Cypress tests within the Electron browser. This GitHub Action configuration
is placed within `.github/workflows/main.yml`.

```yaml
name: Cypress Tests

on: push

jobs:
  cypress-run:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      # Install NPM dependencies, cache them correctly
      # and run all Cypress tests
      - name: Cypress run
        uses: cypress-io/github-action@v5
        with:
          build: npm run build
          start: npm start
```

:::tip

<strong>Try it out</strong>

To try out the example above yourself, fork the
[Cypress Kitchen Sink](https://github.com/cypress-io/cypress-example-kitchensink)
example project and place the above GitHub Action configuration in a newly
created `main.yml` file within `.github/workflows/`.

:::

**How this action works:**

- On _push_ to this repository, this job will provision and start a
  GitHub-hosted Ubuntu Linux instance to run the outlined `steps` for the
  declared `cypress-run` job within the `jobs` section of the configuration.
- The [GitHub checkout Action](https://github.com/marketplace/actions/checkout)
  is used to check out our code from our GitHub repository.
- Finally, our Cypress GitHub Action will:
  - Install npm dependencies
  - Build the project (`npm run build`)
  - Start the project web server (`npm start`)
  - Run the Cypress tests within our GitHub repository within Electron.

## Testing on GitHub with Installed Browsers

[GitHub-hosted runners](https://github.com/actions/runner-images) offer images
with pre-installed browsers to use for testing. The `ubuntu` and `windows`
runners each include Google Chrome, Mozilla Firefox, and Microsoft Edge
pre-installed. The `macos` runners additionally include Apple Safari. Refer to
[GitHub Actions Runner Images](https://github.com/actions/runner-images/blob/main/README.md)
for current details.

Use the action's `browser` parameter to select the desired browser. To change
the above example to select Chrome instead of the default browser Electron, add
`browser: chrome` as follows.

```yaml
- name: Cypress run
  uses: cypress-io/github-action@v5
  with:
    build: npm run build
    start: npm start
    browser: chrome
```

For more examples, see the action's
[Browser](https://github.com/cypress-io/github-action#browser) section.

:::caution

If you are specifying a browser in a parallel job, see
[Specifying Browsers in Parallel Builds](#Specifying-Browsers-in-Parallel-Builds)
for more info on how to avoid errors during runs due to GitHub runner images
being updated with the latest browsers.

:::

## Testing with Cypress Docker Images

GitHub Actions provides the option to specify a container image for the job.
Cypress offers various
[Docker Images](https://github.com/cypress-io/cypress-docker-images) for running
Cypress locally and in CI.

Below we extend the previous example by adding the `container` attribute using a
[Cypress Docker Image](https://github.com/cypress-io/cypress-docker-images)
built with Google Chrome `107`. Specifying a browser version allows our tests to
execute without any influence from browser version changes in the GitHub runner
image.

```yaml
name: Cypress Tests using Cypress Docker Image

on: push

jobs:
  cypress-run:
    runs-on: ubuntu-22.04
    container: cypress/browsers:node16.16.0-chrome107-ff107-edge
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Cypress run
        uses: cypress-io/github-action@v5
        with:
          build: npm run build
          start: npm start
          browser: chrome
```

## Caching Dependencies and Build Artifacts

When working with actions that have multiple jobs, it is recommended to have an
initial "install" job that will download any dependencies and build your app,
and then cache these assets for use later by subsequent jobs.

The Cypress GitHub Action will automatically cache and restore your Node
dependencies for you.

For build assets, you will need to cache and restore them manually.

The `install` job below uses the
[upload-artifact](https://github.com/marketplace/actions/upload-a-build-artifact)
action and saves the state of the `build` directory for the `cypress-run` worker
job.

The
[download-artifact](https://github.com/marketplace/actions/download-a-build-artifact)
action retrieves the `build` directory saved in the `install` job, as seen below
in the `cypress-run` worker job.

```yaml
name: Cypress Tests with Dependency and Artifact Caching

on: push

jobs:
  install:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Cypress install
        uses: cypress-io/github-action@v5
        with:
          # Disable running of tests within install job
          runTests: false
          build: npm run build

      - name: Save build folder
        uses: actions/upload-artifact@v3
        with:
          name: build
          if-no-files-found: error
          path: build

  cypress-run:
    runs-on: ubuntu-22.04
    needs: install
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Download the build folder
        uses: actions/download-artifact@v3
        with:
          name: build
          path: build

      - name: Cypress run
        uses: cypress-io/github-action@v5
        with:
          start: npm start
          browser: chrome
```

View GitHub's guide on
[Storing workflow data as artifacts](https://docs.github.com/en/actions/guides/storing-workflow-data-as-artifacts)
for more info.

## Parallelization

<DocsVideo src="https://youtube.com/embed/96Yn_IiQUJI" />

[Cypress Cloud](/guides/cloud/introduction) offers the ability to
[parallelize and group test runs](/guides/cloud/smart-orchestration/parallelization)
along with additional insights and [analytics](/guides/cloud/analytics) for
Cypress tests.

Using parallelization with the Cypress GitHub Action requires setting up
recording to [Cypress Cloud](https://on.cypress.io/cloud).

GitHub Actions offers a
[matrix strategy](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix)
for declaring different job configurations for a single job definition. Jobs
declared within a matrix strategy can run in parallel, which enables us to run
multiples instances of Cypress at the same time, as we will see later in this
section.

Before diving into an example of a parallelization setup, it is important to
understand the two different types of GitHub Action jobs that we will declare:

- **Install Job**: A job that installs and caches dependencies that will be used
  by subsequent jobs later in the GitHub Action workflow.
- **Worker Job**: A job that handles the execution of Cypress tests and depends
  on the _install job_.

### Install Job

The separation of installation from test running is necessary when running
parallel jobs. It allows for the reuse of various build steps aided by caching.

First, we'll define the `install` step that will be used by the worker jobs
defined in the matrix strategy.

For the `steps`, notice that we pass `runTests: false` to the Cypress GitHub
Action to instruct it only to install and cache Cypress and npm dependencies
_without running the tests_.

The
[upload-artifact](https://github.com/marketplace/actions/upload-a-build-artifact)
action will save the state of the `build` directory for the worker jobs.

```yaml
name: Cypress Tests

on: push

jobs:
  install:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Cypress install
        uses: cypress-io/github-action@v5
        with:
          # Disable running of tests within install job
          runTests: false
          build: npm run build

      - name: Save build folder
        uses: actions/upload-artifact@v3
        with:
          name: build
          if-no-files-found: error
          path: dist
```

### Worker Jobs

Next, we define the worker job named "cypress-run" that will run Cypress tests
as part of a parallelized matrix strategy.

The `download-artifact` action will retrieve the **dist** directory saved in the
install job.

```yaml
name: Cypress Tests

on: push

jobs:
  install:
  # ... omitted install job from above

  cypress-run:
    runs-on: ubuntu-22.04
    needs: install
    strategy:
      # don't fail the entire matrix on failure
      fail-fast: false
      matrix:
        # run copies of the current job in parallel
        containers: [1, 2, 3, 4, 5]
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Download the build folder
        uses: actions/download-artifact@v3
        with:
          name: build

      - name: Cypress run
        uses: cypress-io/github-action@v5
        with:
          record: true
          parallel: true
          start: npm start
```

:::caution

<strong>Ensure Correct Container</strong>

If a docker container was used in the install job, the same docker container
must also be used in the worker jobs.

:::

#### Setting up Parallelization

To set up multiple containers to run in parallel, the matrix option of the
strategy configuration can be set to containers: [1, 2, 3, 4, 5], where the
number of items defined in the containers array will be how many instances of
the job will start up.

For instance, `containers: [1, 2, 3, 4, 5]` will provision five worker instances
to run in parallel. For our purposes, the array's values are arbitrary and
aren't used in the steps.

### Specifying Browsers in Parallel Builds

If you specify a browser in parallel mode, we recommend using a
[Cypress Docker image](#Testing-with-Cypress-Docker-Images) to pin the browser
version used.

When GitHub updates the browsers in their runner images, not all runners get the
new version simultaneously. Your test run might fail if Cypress Cloud detects
differences in the runners between parallel jobs. The Docker image helps ensure
the browser is consistent during an image upgrade.

## Using Cypress Cloud with GitHub Actions

<DocsVideo src="https://youtube.com/embed/Oqq-_QZWzhg" />

In the GitHub Actions configuration, we have defined in the previous section, we
are leveraging three useful features of
[Cypress Cloud](https://on.cypress.io/cloud):

1. [Recording test results with the `record: true` option](https://on.cypress.io/how-do-i-record-runs)
   to [Cypress Cloud](https://on.cypress.io/cloud):

   - In-depth and shareable
     [test reports](/guides/cloud/recorded-runs#Latest-Runs).
   - Visibility into test failures via quick access to error messages, stack
     traces, screenshots, videos, and contextual details.
   - [Integrating testing with the pull-request (PR) process](/guides/cloud/integrations/source-control/github)
     via
     [commit status check guards](/guides/cloud/integrations/source-control/github#Status-checks)
     and convenient
     [test report comments](/guides/cloud/integrations/source-control/github#Pull-request-comments).
   - [Detecting flaky tests](/guides/cloud/flaky-test-management) and surfacing
     them via [Slack alerts](/guides/cloud/flaky-test-management#Slack) or
     [GitHub PR status checks](/guides/cloud/flaky-test-management#GitHub).

2. [Parallelizing test runs](/guides/cloud/smart-orchestration/parallelization)
   and optimizing their execution via
   [intelligent load-balancing](/guides/cloud/smart-orchestration/load-balancing#Balance-strategy)
   of test specs across CI machines with the `parallel: true` option.

3. Organizing and consolidating multiple `cypress run` calls by labeled groups
   into a single report within [Cypress Cloud](https://on.cypress.io/cloud). In
   the example above, we use the `group: "UI - Chrome"` option to organize all
   UI tests for the Chrome browser into a group labeled "UI - Chrome" in the
   [Cypress Cloud](https://on.cypress.io/cloud) report.

## Cypress Real World Example with GitHub Actions

A complete CI workflow against multiple browsers, viewports, and operating
systems is available in the **Cypress Real World App**.

Clone the <Icon name="github" inline="true" contentType="rwa" /> and refer to
the
[.github/workflows/main.yml](https://github.com/cypress-io/cypress-realworld-app/blob/develop/.github/workflows/main.yml)
file.

<DocsImage
  src="/img/guides/github-actions/rwa-run-matrix.png"
  alt="Cypress Real World App GitHub Actions Matrix"
/>

:::info

To see additional how-to examples, you can also refer to our
[Cypress GitHub Action repo](https://github.com/cypress-io/github-action).

:::

## Running E2E Tests in Parallel with Spec File Granularity

Running Cypress E2E tests are very costly, especially when software becomes large with tens of spec files. Although
Cypress offers "dashboard" feature, which claims to offere parallel testing, it is better to confine all CI/CD logics,
including testing, inside GitHub realm. Unfortunately, GitHub Actions offers limited parallelism which make things a
little hard.

What we would like to achieve is the following

- All CI/CD logics, inclusing tests, stays in GitHub
- Each `spec.ts` file is a workflow job, so that CI/CD can parallelize E2E tests at test file granularity
- All E2E tests run (an in parallel as well) in two environments: dev & prod
- No code duplication, i.e. configuration in dev tests never repeats in prod tests

The purpose of having dev and prod environments is to answer the following question during test:

_If a test in production environment fails, is this a code bug or simply because our environment got screwed up?_

For example, when a login page is not showing up, it could be someone's new code put login page into an
undesirable state, in which case it's a bug, or our production server puts our app in a wront HTTP port, in which case
it's an configuration management issue.

The way we package and run web app in the two environments will be very different. In dev
(`./.github/scripts/dev-e2e-test-script.sh`):

```bash
#!/bin/bash

yarn start &
yarn wait-on-dev
yarn e2e --spec "$SPEC_FILE_PATH"
```

In prod (`./.github/scripts/prod-e2e-test-script.sh`):

```bash
#!/bin/bash

yarn build
npm install -g serve
serve -s dist -l 8080 &
yarn wait-on-prod
yarn e2e --spec "$SPEC_FILE_PATH"
```

The main CI/CD workflow looks like this:

:::info

The `list-e2e-test-specs` step scans spec folder using
[List Files Action](https://github.com/marketplace/actions/list-files-action) so that team member won't need to risk
remembing add new spec file into `test_spec` field below

:::

````yml
---

...

jobs:

  ...

  list-e2e-test-specs:
    runs-on: ubuntu-latest
    outputs:
      paths: ${{ steps.list-e2e-test-specs.outputs.paths }}
    steps:
      - name: List Files
        id: list-e2e-test-specs
        uses: mirko-felice/list-files-action@v3.0.5
        with:
          repo: ${{ github.repository }}
          ref: ${{ github.ref }}
          path: "cypress/e2e"
          ext: ".ts"

  e2e-tests:
    name: E2E Tests
    strategy:
      fail-fast: false
      matrix:
        test_env: ["dev", "prod"]
        test_spec: ${{ fromJson(needs.list-e2e-test-specs.outputs.paths) }}
    uses: ./.github/workflows/e2e-tests.yml
    secrets: inherit
    with:
      testing_env: ${{ matrix.test_env }}
      spec_file_path: ${{ matrix.test_spec }}

  ...
``

Next, the `e2e-tests.yml` is dedicated to running a specific spec file in a specific evironment:

```yaml
---
name: CI/CD E2E Tests

"on":
  workflow_call:
    inputs:
      testing_env:
        required: true
        type: string
      spec_file_path:
        required: true
        type: string

jobs:
  e2e-tests:
    name: E2E Tests (${{ inputs.spec_file_path }}) in ${{ inputs.testing_env }} Mode
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        node_version: [16]
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Set node version to ${{ matrix.node_version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node_version }}
      - name: Install dependencies
        run: yarn install
      - name: Load app environment variables
        run: |
          touch .env
          if [[ ${{ inputs.testing_env }} == 'dev' ]]; then
              echo "NODE_ENV=development" >> .env
          else
              echo "NODE_ENV=production" >> .env
          fi
      - name: Run E2E tests in ${{ inputs.testing_env }} mode
        shell: bash
        run: |
          if [[ ${{ inputs.testing_env }} == 'dev' ]]; then
              .github/scripts/dev-e2e-test-script.sh
          else
              .github/scripts/prod-e2e-test-script.sh
          fi
        env:
          SPEC_FILE_PATH: ${{ inputs.spec_file_path }}
      - name: Upload test videos and screenshots on test failure
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: ${{ inputs.testing_env }}-${{ inputs.spec_file_path }}-${{ matrix.node_version }}
          path: |
            ./cypress/videos
            ./cypress/screenshots
````

## Common Problems and Solutions

### Re-run jobs passing with empty tests

We recommend passing the `GITHUB_TOKEN` secret (created by the GH Action
automatically) as an environment variable. This will allow the accurate
identification of each build to avoid confusion when re-running a build.

```yml
name: Cypress tests
on: push
jobs:
  cypress-run:
    name: Cypress run
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Cypress run
        uses: cypress-io/github-action@v5
        with:
          record: true
        env:
          # pass GitHub token to detect new build vs re-run build
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
```

### Pull requests commit message is `merge SHA into SHA`

You can overwrite the commit message sent to Cypress Cloud by setting an
environment variable. See
[Issue #124](https://github.com/cypress-io/github-action/issues/124) for more
details.

```yml
name: Cypress tests
on: push
jobs:
  cypress-run:
    name: Cypress run
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Cypress run
        uses: cypress-io/github-action@v5
        with:
          record: true
        env:
          # overwrite commit message sent to Cypress Cloud
          COMMIT_INFO_MESSAGE: ${{github.event.pull_request.title}}
          # re-enable PR comment bot
          COMMIT_INFO_SHA: ${{github.event.pull_request.head.sha}}
```

:::info

We also recommend adding `COMMIT_INFO_SHA` to re-enable
[Cypress bot PR comments](https://on.cypress.io/github#Pull-request-comments).
See
[this comment](https://github.com/cypress-io/github-action/issues/124#issuecomment-716584972)
for more details.

:::

## See also

- [Test anything that runs in the browser with Cypress and GitHub Actions](https://www.youtube.com/watch?v=gokM_zEmWLA)
