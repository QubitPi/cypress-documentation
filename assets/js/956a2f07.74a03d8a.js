"use strict";(self.webpackChunkcypress_docusaurus_ts=self.webpackChunkcypress_docusaurus_ts||[]).push([[916],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),d=i,h=c["".concat(l,".").concat(d)]||c[d]||m[d]||r;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9437:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const r={title:"Custom Queries",sidebar_position:30},o=void 0,s={unversionedId:"api/cypress-api/custom-queries",id:"api/cypress-api/custom-queries",title:"Custom Queries",description:"Starting in Cypress 12, Cypress comes with its own API for creating custom",source:"@site/docs/api/cypress-api/custom-queries.mdx",sourceDirName:"api/cypress-api",slug:"/api/cypress-api/custom-queries",permalink:"/cypress-documentation/api/cypress-api/custom-queries",draft:!1,editUrl:"https://github.com/cypress-io/cypress-documentation/tree/main/docs/api/cypress-api/custom-queries.mdx",tags:[],version:"current",lastUpdatedAt:1696480553,formattedLastUpdatedAt:"Oct 5, 2023",sidebarPosition:30,frontMatter:{title:"Custom Queries",sidebar_position:30},sidebar:"api",previous:{title:"Custom Commands",permalink:"/cypress-documentation/api/cypress-api/custom-commands"},next:{title:"Cypress.arch",permalink:"/cypress-documentation/api/cypress-api/arch"}},l={},u=[{value:"Syntax",id:"Syntax",level:2},{value:"Usage",id:"Usage",level:3},{value:"Arguments",id:"Arguments",level:3},{value:"Examples",id:"Examples",level:2},{value:"<code>.focused()</code>",id:"focused",level:3},{value:"The outer function",id:"The-outer-function",level:4},{value:"The inner function",id:"The-inner-function",level:4},{value:"Using existing queries",id:"Using-existing-queries",level:3},{value:"Overwriting Existing Queries",id:"Overwriting-Existing-Queries",level:3},{value:"Adding alias support to <code>.contains()</code>",id:"Adding-alias-support-to-contains",level:4},{value:"Validation",id:"Validation",level:2},{value:"Notes",id:"Notes",level:2},{value:"Best Practices",id:"Best-Practices",level:3},{value:"1. Don&#39;t make everything a custom query",id:"1-Dont-make-everything-a-custom-query",level:4},{value:"2. Don&#39;t overcomplicate things",id:"2-Dont-overcomplicate-things",level:4},{value:"History",id:"History",level:2},{value:"See also",id:"See-also",level:2}],p=(c="Icon",function(e){return console.warn("Component "+c+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var c;const m={toc:u};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Starting in Cypress 12, Cypress comes with its own API for creating custom\nqueries. The built in Cypress queries use the very same API that's explained\nbelow."),(0,i.kt)("p",null,"Queries are a type of command, used for ",(0,i.kt)("em",{parentName:"p"},"querying")," the state of your\napplication. They are different from other commands in that they follow three\nimportant rules:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Queries are ",(0,i.kt)("em",{parentName:"li"},"synchronous.")," They do not return or await promises."),(0,i.kt)("li",{parentName:"ol"},"Queries are ",(0,i.kt)("em",{parentName:"li"},"retriable.")," Once you return the inner function, Cypress takes\ncontrol, handling retries on your behalf."),(0,i.kt)("li",{parentName:"ol"},"Queries are ",(0,i.kt)("em",{parentName:"li"},"idempotent.")," Once you return the inner function, Cypress will\ninvoke it repeatedly. Invoking the inner function multiple times must not\nchange the state of your application.")),(0,i.kt)("p",null,"With these rules, queries are simple to write and extremely powerful. They are\nthe building blocks on which Cypress' API is built. To learn more about the\ndifferences between commands and queries, see our\n",(0,i.kt)("a",{parentName:"p",href:"/guides/core-concepts/retry-ability#Only-queries-are-retried"},"guide on Retry-ability"),"."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you want to chain together existing Cypress commands as a shortcut, you\nprobably want to write a ",(0,i.kt)("a",{parentName:"p",href:"/api/cypress-api/custom-commands"},"custom command"),"\ninstead."),(0,i.kt)("p",{parentName:"admonition"},"You'll also want to write a command instead of a query if your method needs to\nbe asynchronous, or if it can be called only once.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"We recommend defining queries in your ",(0,i.kt)("inlineCode",{parentName:"p"},"cypress/support/commands.js")," file, since\nit is loaded before any test files are evaluated via an import statement in the\n",(0,i.kt)("a",{parentName:"p",href:"/guides/core-concepts/writing-and-organizing-tests#Support-file"},"supportFile"),".")),(0,i.kt)("h2",{id:"Syntax"},"Syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"Cypress.Commands.addQuery(name, callbackFn)\nCypress.Commands.overwriteQuery(name, callbackFn)\n")),(0,i.kt)("h3",{id:"Usage"},"Usage"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)(p,{name:"check-circle",color:"green",mdxType:"Icon"})," Correct Usage")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"Cypress.Commands.addQuery('getById', function (id) {\n  return (subject) => newSubject\n})\n\nCypress.Commands.overwriteQuery('get', function (originalFn, ...args) {\n  return originalFn.apply(this, args)\n})\n")),(0,i.kt)("h3",{id:"Arguments"},"Arguments"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)(p,{name:"angle-right",mdxType:"Icon"})," name")," ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"(String)"))),(0,i.kt)("p",null,"The name of the query you're adding."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)(p,{name:"angle-right",mdxType:"Icon"})," callbackFn")," ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"(Function)"))),(0,i.kt)("p",null,"Pass a function that receives the arguments passed to the query."),(0,i.kt)("p",null,"This outer function is invoked once. It should return a function that takes a\nsubject and returns a new subject; this inner function might be called multiple\ntimes."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The query API relies on ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," to set timeouts, which means that ",(0,i.kt)("inlineCode",{parentName:"p"},"callbackFn"),"\nshould always use ",(0,i.kt)("inlineCode",{parentName:"p"},"function () {}")," and not be an arrow function (",(0,i.kt)("inlineCode",{parentName:"p"},"() => {}"),").")),(0,i.kt)("h2",{id:"Examples"},"Examples"),(0,i.kt)("h3",{id:"focused"},(0,i.kt)("inlineCode",{parentName:"h3"},".focused()")),(0,i.kt)("p",null,"The callback function can be thought of as two separate parts. The ",(0,i.kt)("em",{parentName:"p"},"outer\nfunction"),", which is invoked once, where you perform setup and state management,\nand the ",(0,i.kt)("em",{parentName:"p"},"query function"),", which might be called repeatedly."),(0,i.kt)("p",null,"Let's look at an example. This is actual Cypress code - how ",(0,i.kt)("inlineCode",{parentName:"p"},".focused()")," is\nimplemented internally, with some small adjustments to make it work from a\nsupport file. The only thing omitted here for simplicity is the TypeScript\ndefinitions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"Cypress.Commands.addQuery('focused2', function focused2(options = {}) {\n  const log = options.log !== false && Cypress.log({ timeout: options.timeout })\n\n  this.set('timeout', options.timeout)\n\n  return () => {\n    let $el = cy.getFocused()\n\n    log &&\n      cy.state('current') === this &&\n      log.set({\n        $el,\n        consoleProps: () => {\n          return {\n            Yielded: $el?.length ? $el[0] : '--nothing--',\n            Elements: $el != null ? $el.length : 0,\n          }\n        },\n      })\n\n    if (!$el) {\n      $el = cy.$$(null)\n      $el.selector = 'focused'\n    }\n\n    return $el\n  }\n})\n")),(0,i.kt)("h4",{id:"The-outer-function"},"The outer function"),(0,i.kt)("p",null,"The outer function is called once each time test uses the query. It performs\nsetup and state management:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function focused2(options = {}) {\n  const log = options.log !== false && Cypress.log({ timeout: options.timeout })\n\n  this.set('timeout', options.timeout)\n\n  return () => { ... } // Inner function\n}\n")),(0,i.kt)("p",null,"Let's look at this piece by piece."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function focused2(options = {}) { ... }\n")),(0,i.kt)("p",null,"Cypress passes the outer function whatever arguments the user calls it with; no\nprocessing or validation is done on the user's arguments. In our case,\n",(0,i.kt)("inlineCode",{parentName:"p"},".focused2()")," accepts one optional argument, ",(0,i.kt)("inlineCode",{parentName:"p"},"options"),"."),(0,i.kt)("p",null,"If you wanted to validate the incoming arguments, you might add something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"if (options === null || !_.isPlainObject(options)) {\n  const err = `cy.root() requires an \\`options\\` object. You passed in: \\`{options}\\``\n  throw new TypeError(err)\n}\n")),(0,i.kt)("p",null,"This is a general pattern: when something goes wrong, queries just throw an\nerror. Cypress will handle displaying the error in the Command Log."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const log = options.log !== false && Cypress.log({ timeout: options.timeout })\n")),(0,i.kt)("p",null,"If the user has not set ",(0,i.kt)("inlineCode",{parentName:"p"},"{ log: false }"),", we create a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Cypress.log()"),"\ninstance. See ",(0,i.kt)("a",{parentName:"p",href:"/api/cypress-api/cypress-log"},(0,i.kt)("inlineCode",{parentName:"a"},"Cypress.log()"))," for more\ninformation."),(0,i.kt)("p",null,"This line is setup code, so it lives in the outer function - we only want it to\nrun once, creating the log message when Cypress first begins executing this\nquery. We hold onto a reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"Log")," instance. We'll update it later with\nadditional details when the inner function executes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"this.set('timeout', options.timeout)\n")),(0,i.kt)("p",null,"When defining ",(0,i.kt)("inlineCode",{parentName:"p"},"focused2()"),", it's important to note that we used ",(0,i.kt)("inlineCode",{parentName:"p"},"function"),",\nrather than an arrow function. This gives us access to ",(0,i.kt)("inlineCode",{parentName:"p"},"this"),", where we can set\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"timeout"),". If you don't call ",(0,i.kt)("inlineCode",{parentName:"p"},"this.set('timeout')"),", or call it with ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),", your query will use the\n",(0,i.kt)("a",{parentName:"p",href:"/guides/core-concepts/introduction-to-cypress#Timeouts"},"default timeout"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  return () => { ... }\n")),(0,i.kt)("h4",{id:"The-inner-function"},"The inner function"),(0,i.kt)("p",null,"The outer function's return value is the inner function."),(0,i.kt)("p",null,"The inner function is called any number of times. It's first invoked repeatedly\nuntil it passes or the query times out; it can then be invoked again later to\ndetermine the subject of future commands, or when the user retrieves an alias."),(0,i.kt)("p",null,"The inner function is called with one argument: the previous subject. Cypress\nperforms no validation on this - it could be any type, including ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},".focused2()")," ignores any previous subject, but many queries do not - for\nexample, ",(0,i.kt)("inlineCode",{parentName:"p"},".contains()")," accepts only certain types of subjects. You can use\nCypress' builtin ",(0,i.kt)("inlineCode",{parentName:"p"},"ensures")," functions, as ",(0,i.kt)("inlineCode",{parentName:"p"},".contains()")," does:\n",(0,i.kt)("inlineCode",{parentName:"p"},"cy.ensureSubjectByType(subject, ['optional', 'element', 'window', 'document'], this)")),(0,i.kt)("p",null,"or you can perform your own validation and simply throw an error:\n",(0,i.kt)("inlineCode",{parentName:"p"},"if (!_.isString(subject)) { throw new Error('MyCustomCommand only accepts strings as a subject!') }")),(0,i.kt)("p",null,"If the inner function throws an error, Cypress will retry it after a short delay\nuntil it either passes or the query times out. This is the core of Cypress'\nretry-ability, and the guarantees it provides that your tests interact with the\npage as a user would."),(0,i.kt)("p",null,"Looking back to our ",(0,i.kt)("inlineCode",{parentName:"p"},".focused2()")," example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"return () => {\n  let $el = cy.getFocused()\n\n  log &&\n    cy.state('current') === this &&\n    log.set({\n      $el,\n      consoleProps: () => {\n        return {\n          Yielded: $el?.length ? $el[0] : '--nothing--',\n          Elements: $el != null ? $el.length : 0,\n        }\n      },\n    })\n\n  if (!$el) {\n    $el = cy.$$(null)\n    $el.selector = 'focused'\n  }\n\n  return $el\n}\n")),(0,i.kt)("p",null,"Piece by piece again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let $el = cy.getFocused()\n")),(0,i.kt)("p",null,"This is the 'business end' of ",(0,i.kt)("inlineCode",{parentName:"p"},".focused2()")," - finding the element on the page\nthat's currently focused."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"    log && cy.state('current') === this && log.set({...})\n")),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," is defined (ie, the user did not pass in ",(0,i.kt)("inlineCode",{parentName:"p"},"{ log: false }"),"), and this\nquery is the current command, we update the log message with new information,\nsuch as ",(0,i.kt)("inlineCode",{parentName:"p"},"$el")," (the subject we're about to yield from this query), and the\n",(0,i.kt)("inlineCode",{parentName:"p"},"consoleProps"),", a function that\n",(0,i.kt)("a",{parentName:"p",href:"/guides/core-concepts/cypress-app#Console-output"},"returns console output")," for\nthe user."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"if (!$el) {\n  $el = cy.$$(null)\n  $el.selector = 'focused'\n}\n")),(0,i.kt)("p",null,"If there's no focused element on the page, we create an empty jquery object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"return $el\n")),(0,i.kt)("p",null,"The return value of the inner function becomes the new subject for the next\ncommand."),(0,i.kt)("p",null,"With this return value in hand, Cypress verifies any upcoming assertions, such\nas user's ",(0,i.kt)("inlineCode",{parentName:"p"},".should()")," commands, or if there are none, the default implicit\nassertions that the subject should exist."),(0,i.kt)("h3",{id:"Using-existing-queries"},"Using existing queries"),(0,i.kt)("p",null,"Many custom queries are wrappers around other, already implemented queries -\nmost commonly ",(0,i.kt)("inlineCode",{parentName:"p"},".get()"),"."),(0,i.kt)("p",null,"This is quite simple:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"Cypress.Commands.addQuery('getFirstButton', function getFirstButton(options) {\n  const getFn = cy.now('get', 'button:first', options)\n\n  return (subject) => {\n    console.log('The subject we received was:', subject)\n\n    const btn = getFn(subject)\n\n    console.log('.get returned this element:', btn)\n\n    return btn\n  }\n})\n")),(0,i.kt)("p",null,"Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.now()")," on a query calls the outer function of that query, and\nreturns the inner function. In our case, we call ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"button:first")," and\npass through whatever ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," the user provided us."),(0,i.kt)("p",null,"In our own inner function, we can then call ",(0,i.kt)("inlineCode",{parentName:"p"},"getFn"),", and do whatever we want\nwith the return value."),(0,i.kt)("p",null,"Remember that commands - including queries - don't have a meaningful return\nvalue. Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.get()")," directly would just add it to the queue of commands to\nbe executed later (which is not idempotent!). ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.now()")," lets us directly call\nthe original ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," query function, without Cypress' chaining and command queue\nlogic wrapped around it."),(0,i.kt)("h3",{id:"Overwriting-Existing-Queries"},"Overwriting Existing Queries"),(0,i.kt)("p",null,"You can also modify the behavior of existing Cypress queries. This is useful to\nextend the functionality of builtin commands."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"Cypress.Commands.overwriteQuery")," can only overwrite queries, not other\ncommands. If you want to modify the behavior of a non-query command, you'll need\nto use ",(0,i.kt)("a",{parentName:"p",href:"/api/cypress-api/custom-commands"},(0,i.kt)("inlineCode",{parentName:"a"},"Cypress.Commands.overwrite"))," instead.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Remember that query functions rely on ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," - when you invoke ",(0,i.kt)("inlineCode",{parentName:"p"},"originalFn"),", be\nsure to use ",(0,i.kt)("inlineCode",{parentName:"p"},".call")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".apply"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"Cypress.Commands.overwriteQuery('get', function (originalFn, ...args) {\n  console.log('get called with args:', args)\n\n  const innerFn = originalFn.apply(this, args)\n\n  return (subject) => {\n    console.log('get inner function called with subject:', subject)\n\n    return innerFn(subject)\n  }\n})\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"originalFn")," is the function originally passed to\n",(0,i.kt)("inlineCode",{parentName:"p"},"Cypress.Commands.addQuery")," - it is a ",(0,i.kt)("strong",{parentName:"p"},"function that returns a function.")," This\ngives you access to both the outer arguments (before you call ",(0,i.kt)("inlineCode",{parentName:"p"},"originalFn"),") and\nthe inner function (the return value of ",(0,i.kt)("inlineCode",{parentName:"p"},"originalFn"),"), giving you a great deal\nof control over how the query executes."),(0,i.kt)("h4",{id:"Adding-alias-support-to-contains"},"Adding alias support to ",(0,i.kt)("inlineCode",{parentName:"h4"},".contains()")),(0,i.kt)("p",null,"In this example, ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.contains()")," is extended to support querying for aliased\nsubjects, like ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.contains('@foo')"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"Cypress.Commands.overwriteQuery(\n  'contains',\n  function (originalFn, filter, text, userOptions) {\n    if (_.isString(filter) && filter[0] === '@') {\n      let alias = cy.state('aliases')[filter.slice(1)]\n      let subject = cy.getSubjectFromChain(alias?.subjectChain)\n      filter = subject\n    }\n\n    if (_.isString(text) && text[0] === '@') {\n      let alias = cy.state('aliases')[text.slice(1)]\n      let subject = cy.getSubjectFromChain(alias?.subjectChain)\n      text = subject\n    }\n\n    return originalFn.call(this, filter, text, userOptions)\n  }\n)\n\ncy.wrap('li').as('element')\ncy.wrap('asdf 1').as('content')\n\ncy.contains('@element', '@content')\n")),(0,i.kt)("h2",{id:"Validation"},"Validation"),(0,i.kt)("p",null,"As noted in the examples above, Cypress performs very little validation around\nqueries - it is the responsibility of each implementation to ensure that its\narguments and subject are of the correct type."),(0,i.kt)("p",null,"Cypress has several builtin 'ensures' which can be helpful in this regard:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cy.ensureSubjectByType(subject, types, this)"),": Accepts an array with any of\nthe strings ",(0,i.kt)("inlineCode",{parentName:"li"},"optional"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"element"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"document"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"window"),".\n",(0,i.kt)("inlineCode",{parentName:"li"},"ensureSubjectByType")," is how\n",(0,i.kt)("a",{parentName:"li",href:"/api/cypress-api/custom-commands#Validations"},(0,i.kt)("inlineCode",{parentName:"a"},"prevSubject")," validation")," is\nimplemented for commmands."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cy.ensureElement(subject, queryName)"),": Ensure that the passed in ",(0,i.kt)("inlineCode",{parentName:"li"},"subject")," is\none or more DOM elements."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cy.ensureWindow(subject)"),": Ensure that the passed in ",(0,i.kt)("inlineCode",{parentName:"li"},"subject")," is a ",(0,i.kt)("inlineCode",{parentName:"li"},"window"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cy.ensureDocument(subject)"),": Ensure that the passed in ",(0,i.kt)("inlineCode",{parentName:"li"},"subject")," is a\n",(0,i.kt)("inlineCode",{parentName:"li"},"document"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cy.ensureAttached(subject, queryName)"),": Ensure that DOM element(s) are\nattached to the page."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cy.ensureNotDisabled(subject)"),": Ensure that form elements aren't disabled."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cy.ensureVisibility(subject)"),": Ensure that a DOM element is visible on the\npage.")),(0,i.kt)("p",null,"There's nothing special about these functions - they simply validate their\nargument and throw an error if the check fails. You can throw errors of any type\nat any time inside your queries - Cypress will catch and handle it\nappropriately."),(0,i.kt)("h2",{id:"Notes"},"Notes"),(0,i.kt)("h3",{id:"Best-Practices"},"Best Practices"),(0,i.kt)("h4",{id:"1-Dont-make-everything-a-custom-query"},"1. Don't make everything a custom query"),(0,i.kt)("p",null,"Custom queries work well when you're needing to describe behavior that's\ndesirable across ",(0,i.kt)("strong",{parentName:"p"},"all of your tests"),". Examples would be ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.findBreadcrumbs()"),"\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.getLoginForm()"),". These are specific to your application and can be used\neverywhere."),(0,i.kt)("p",null,"However, this pattern can be used and abused. Let's not forget - writing Cypress\ntests is ",(0,i.kt)("strong",{parentName:"p"},"JavaScript"),", and it's often more efficient to write a function for\nrepeatable behavior than it is to implement a custom query."),(0,i.kt)("h4",{id:"2-Dont-overcomplicate-things"},"2. Don't overcomplicate things"),(0,i.kt)("p",null,"Every custom query you write is generally an abstraction for locating elements\non the page. That means you and your team members exert much more mental effort\nto understand what your custom command does."),(0,i.kt)("p",null,"There's no reason to add this level of complexity when the builtin queries are\nalready quite expressive and powerful."),(0,i.kt)("p",null,"Don't do things like:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)(p,{name:"exclamation-triangle",color:"red",mdxType:"Icon"}))," ",(0,i.kt)("inlineCode",{parentName:"li"},"cy.getButton()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)(p,{name:"exclamation-triangle",color:"red",mdxType:"Icon"}))," ",(0,i.kt)("inlineCode",{parentName:"li"},".getFirstTableRow()"))),(0,i.kt)("p",null,"Both of these are wrapping ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.get(selector)"),". It's completely unnecessary. Just\ncall ",(0,i.kt)("inlineCode",{parentName:"p"},".get('button')")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".get('tr:first')"),"."),(0,i.kt)("p",null,"Testing in Cypress is all about ",(0,i.kt)("strong",{parentName:"p"},"readability")," and ",(0,i.kt)("strong",{parentName:"p"},"simplicity"),". You don't\nhave to do that much actual programming to get a lot done. You also don't need\nto worry about keeping your code as DRY as possible. Test code serves a\ndifferent purpose than app code. Understandability and debuggability should be\nprioritized above all else."),(0,i.kt)("p",null,"Try not to overcomplicate things and create too many abstractions."),(0,i.kt)("h2",{id:"History"},"History"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Version"),(0,i.kt)("th",{parentName:"tr",align:null},"Changes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/guides/references/changelog#12-6-0"},"12.6.0")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"overrideQuery")," API added")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/guides/references/changelog#12-0-0"},"12.0.0")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"addQuery")," API added")))),(0,i.kt)("h2",{id:"See-also"},"See also"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"See how to add\n",(0,i.kt)("a",{parentName:"li",href:"/guides/tooling/typescript-support#Types-for-custom-commands"},"TypeScript support for custom commands")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/plugins#custom-commands"},"Plugins using custom commands")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/api/cypress-api/cypress-log"},"Cypress.log()"))))}d.isMDXComponent=!0}}]);