"use strict";(self.webpackChunkcypress_docusaurus_ts=self.webpackChunkcypress_docusaurus_ts||[]).push([[2834],{5359:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>r,contentTitle:()=>c,default:()=>u,frontMatter:()=>n,metadata:()=>o,toc:()=>l});var s=t(5893),a=t(1151);const n={sidebar_label:"Maximize coverage",title:"Maximize coverage | Cypress Accessibility Documentation",description:"Expand accessibility testing by combining Cypress Accessibility's automated checks with custom assertions tailored to your application.",sidebar_position:70},c="Maximize coverage",o={id:"accessibility/guides/maximize-coverage",title:"Maximize coverage | Cypress Accessibility Documentation",description:"Expand accessibility testing by combining Cypress Accessibility's automated checks with custom assertions tailored to your application.",source:"@site/docs/accessibility/guides/maximize-coverage.mdx",sourceDirName:"accessibility/guides",slug:"/accessibility/guides/maximize-coverage",permalink:"/accessibility/guides/maximize-coverage",draft:!1,unlisted:!1,editUrl:"https://github.com/cypress-io/cypress-documentation/tree/main/docs/accessibility/guides/maximize-coverage.mdx",tags:[],version:"current",lastUpdatedAt:1749088520,formattedLastUpdatedAt:"Jun 5, 2025",sidebarPosition:70,frontMatter:{sidebar_label:"Maximize coverage",title:"Maximize coverage | Cypress Accessibility Documentation",description:"Expand accessibility testing by combining Cypress Accessibility's automated checks with custom assertions tailored to your application.",sidebar_position:70},sidebar:"accessibility",previous:{title:"Detect and manage changes",permalink:"/accessibility/guides/detect-changes"},next:{title:"Accessibility automation principles",permalink:"/accessibility/guides/accessibility-automation"}},r={},l=[{value:"Examples",id:"Examples",level:2},{value:"Button Accessibility Test",id:"Button-Accessibility-Test",level:3},{value:"Accessibility &quot;hotspots&quot;",id:"Accessibility-hotspots",level:2},{value:"Combining testing approaches",id:"Combining-testing-approaches",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...e.components},{ProductHeading:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ProductHeading",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t,{product:"accessibility"}),"\n",(0,s.jsx)(i.h1,{id:"Maximize-coverage",children:"Maximize coverage"}),"\n",(0,s.jsx)(i.p,{children:"As you become more familiar with accessibility violations and their underlying principles, you'll notice the connection between generic, automated checks (e.g., Axe Core\xae) and the specific user-facing behaviors of your application. Often, the insights gained from Cypress Accessibility's automated checks can guide you to create custom assertions tailored to your application's unique requirements."}),"\n",(0,s.jsx)(i.h2,{id:"Examples",children:"Examples"}),"\n",(0,s.jsx)(i.h3,{id:"Button-Accessibility-Test",children:"Button Accessibility Test"}),"\n",(0,s.jsx)(i.p,{children:"For example, Cypress Accessibility might flag a button with a missing accessible name. While adding any text might satisfy Axe Core's rule, the actual text should align with your application's context. Once you address the issue in your codebase, you can enhance your Cypress tests by asserting the specific text, ensuring that future developers understand its importance as part of the application's specification."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-js",children:"describe('Button Accessibility Test', () => {\n  it('should have the correct accessible name for the button', () => {\n    // Visit the page containing the button\n    cy.visit('/your-page-url')\n\n    // Select the button by its identifier\n    cy.get('[data-test-id=\"submit-button\"]')\n      // Ensure the button has an accessible name\n      .should('have.attr', 'aria-label', 'Submit Form')\n      // Optionally, assert the button contains the visible text\n      .and('contain', 'Submit')\n  })\n})\n"})}),"\n",(0,s.jsx)(i.p,{children:"This principle can extend to larger and more complex scenarios."}),"\n",(0,s.jsx)(i.h2,{id:"Accessibility-hotspots",children:'Accessibility "hotspots"'}),"\n",(0,s.jsx)(i.p,{children:'Each violation detected by Cypress Accessibility serves as a signal that accessibility might not have been adequately considered in a specific area of your application. Since Cypress Accessibility provides full DOM visibility for every violation, you can efficiently perform manual checks on related patterns in the UI. This approach often reveals accessibility "hotspots", where usability issues may exist that automated tools cannot detect.'}),"\n",(0,s.jsx)(i.p,{children:"Conducting manual audits in these areas can uncover deeper usability challenges. These findings can then be cataloged, addressed, and regression-tested using Cypress automation."}),"\n",(0,s.jsx)(i.h2,{id:"Combining-testing-approaches",children:"Combining testing approaches"}),"\n",(0,s.jsx)(i.p,{children:"A hybrid approach that combines Cypress Accessibility's always-on automated checks with custom assertions can significantly improve long-term accessibility quality. This approach ensures accessibility regressions are caught and fixed, regardless of whether they were initially detected automatically or through manual review."}),"\n",(0,s.jsx)(i.p,{children:"Automated tools like Axe Core\xae are estimated to detect approximately 57% of common accessibility issues. By incorporating manual insights and user feedback into your Cypress test suite, you can achieve far greater coverage. Explicit assertions on top of automated error detection empower your pipeline to deliver consistent, actionable feedback about accessibility regressions."})]})}function u(e={}){const{wrapper:i}={...(0,a.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,i,t)=>{t.d(i,{Z:()=>o,a:()=>c});var s=t(7294);const a={},n=s.createContext(a);function c(e){const i=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),s.createElement(n.Provider,{value:i},e.children)}}}]);