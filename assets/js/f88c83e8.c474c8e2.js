"use strict";(self.webpackChunkcypress_docusaurus_ts=self.webpackChunkcypress_docusaurus_ts||[]).push([[3915],{2046:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=s(5893),n=s(1151);const a={title:"Comparing Accessibility Reports | Cypress Documentation",description:"Review the main areas to pay attention to when first reviewing an accessibility report for a Cypress run.",sidebar_position:40,sidebar_label:"Compare reports"},r="Compare reports",o={id:"accessibility/core-concepts/compare-reports",title:"Comparing Accessibility Reports | Cypress Documentation",description:"Review the main areas to pay attention to when first reviewing an accessibility report for a Cypress run.",source:"@site/docs/accessibility/core-concepts/compare-reports.mdx",sourceDirName:"accessibility/core-concepts",slug:"/accessibility/core-concepts/compare-reports",permalink:"/accessibility/core-concepts/compare-reports",draft:!1,unlisted:!1,editUrl:"https://github.com/cypress-io/cypress-documentation/tree/main/docs/accessibility/core-concepts/compare-reports.mdx",tags:[],version:"current",lastUpdatedAt:1750130633,formattedLastUpdatedAt:"Jun 17, 2025",sidebarPosition:40,frontMatter:{title:"Comparing Accessibility Reports | Cypress Documentation",description:"Review the main areas to pay attention to when first reviewing an accessibility report for a Cypress run.",sidebar_position:40,sidebar_label:"Compare reports"},sidebar:"accessibility",previous:{title:"Accessibility score",permalink:"/accessibility/core-concepts/accessibility-score"},next:{title:"How it works",permalink:"/accessibility/core-concepts/how-it-works"}},l={},c=[{value:"Use cases",id:"Use-cases",level:2},{value:"Content of the report",id:"Content-of-the-report",level:2},{value:"How to compare runs",id:"How-to-compare-runs",level:2},{value:"Details of each section",id:"Details-of-each-section",level:2},{value:"New failed elements",id:"New-failed-elements",level:3},{value:"Single-View diff vs whole-run diff",id:"Single-View-diff-vs-whole-run-diff",level:4},{value:"Resolved elements",id:"Resolved-elements",level:3},{value:"What if there are no changes?",id:"What-if-there-are-no-changes",level:3},{value:"Ensuring a good comparison",id:"Ensuring-a-good-comparison",level:2},{value:"Stabilizing the comparison",id:"Stabilizing-the-comparison",level:3},{value:"Stable Views",id:"Stable-Views",level:3},{value:"Stable Elements",id:"Stable-Elements",level:3},{value:"Stable underlying reporting area",id:"Stable-underlying-reporting-area",level:3}];function h(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.a)(),...e.components},{DocsImage:s,DocsVideo:a,ProductHeading:r}=i;return s||u("DocsImage",!0),a||u("DocsVideo",!0),r||u("ProductHeading",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r,{product:"accessibility"}),"\n",(0,t.jsx)(i.h1,{id:"Compare-reports",children:"Compare reports"}),"\n",(0,t.jsxs)(i.p,{children:["Accessibility reports from different runs can be compared in the ",(0,t.jsx)(i.a,{href:"/cloud/features/branch-review#Getting-Started",children:"Branch Review"})," area of Cypress Cloud. This allows you to instantly see if any new issues have been introduced, and drill in to see full-page HTML and CSS snapshots showing only the new issues."]}),"\n",(0,t.jsx)(i.p,{children:"See the video below for an example of using Branch Review in a Pull Request:"}),"\n",(0,t.jsx)(a,{src:"https://www.youtube.com/embed/k3vq57O4P4M",title:"Accessibility branch review demo"}),"\n",(0,t.jsx)(i.p,{children:"Comparing two accessibility reports manually is usually a challenge:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"each report may test thousands of application snapshots for a single Cypress run"}),"\n",(0,t.jsx)(i.li,{children:"80+ accessibility rules are tested for each snapshot"}),"\n",(0,t.jsx)(i.li,{children:"many different pages or components are tested and may have changes"}),"\n",(0,t.jsx)(i.li,{children:"elements might be identified differently in each run"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Branch Review for Cypress Accessibility is set up to help you easily browse this nested set of changes and find what's important. You can review any accessibility violation increases found for specific rules, and drill into the Views where those changes happened."}),"\n",(0,t.jsx)(i.h2,{id:"Use-cases",children:"Use cases"}),"\n",(0,t.jsx)(i.p,{children:"Comparing the results from different runs is useful in multiple scenarios."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Key use cases:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Pre-merge checks"}),": Know if any net-new issues are introduced by UI code changes."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Monitoring changes"}),": Compare nightly monitoring runs and track down the introduction of new problems caused by underlying changes in the application."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Detecting content issues"}),": Sometimes content editors can introduce accessibility issues unrelated to code changes. Seeing the example issues presented visually, in context, helps you quickly triage whether you are dealing with a recent code change issue, or a content authorship problem."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Reviewing AI-generated code changes"}),": The increased use of AI to generate and/or review front-end code creates some increased risks of accessibility regressions making it to production. The increase or decrease of accessibility issues when reviewing a pull request helps you understand the impact of the change."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Tracing the introduction of issues"}),": With dropdowns for each run, it's easy to rapidly compare different A and B runs to find the exact commit that introduced a problem."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Demonstrating the resolution of issues"}),": Confirm the effect of your improvements, and share the overview with your team to more quickly review code changes."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"Content-of-the-report",children:"Content of the report"}),"\n",(0,t.jsx)(s,{src:"/img/accessibility/core-concepts/branch-review-example-diff.png",alt:"Cypress Accessibility Branch Review showing two main sections - New Failed Elements and Resolved Elements"}),"\n",(0,t.jsx)(i.p,{children:"The key to understanding the run comparison report is that the Changed run is the focal point for all data that will be displayed, and the Base run is used as a reference point for comparison. So everywhere that you see an element, or drill in for more details, you will only see data from the Changed run."}),"\n",(0,t.jsx)(i.p,{children:"The Branch Review report is divided into two sections:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"New failed elements"}),": Counts of elements that have failures in the Changed run, where matching failures were not found on the Base run. These are listed by View, for each accessibility rule where new failures were detected."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Resolved elements"}),": Counts of elements that had failures detected in the Base run which are no longer detected in the Changed run. These are also listed as improvements in each View, under the accessibility rules that had improvements."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"If the Changed run is associated with a Pull Request and runs the same overall test suite as the Base run, the changes in the report are likely due to code changes in the pull request."}),"\n",(0,t.jsx)(i.h2,{id:"How-to-compare-runs",children:"How to compare runs"}),"\n",(0,t.jsxs)(i.p,{children:["The first step is to get to the ",(0,t.jsx)(i.a,{href:"/cloud/features/branch-review",children:"Branch Review"})," area of Cypress Cloud, which will let you compare one branch against another - or different runs on the same branch, if needed.\nYou can access this area by clicking the branch name associated with a run, or in several other ways. ",(0,t.jsx)(i.a,{href:"/cloud/features/branch-review",children:"Learn more about how to compare runs"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"Details-of-each-section",children:"Details of each section"}),"\n",(0,t.jsx)(i.h3,{id:"New-failed-elements",children:"New failed elements"}),"\n",(0,t.jsxs)(i.p,{children:["A ",(0,t.jsx)(i.strong,{children:"new failed element"})," is any failed element which either did not exist in the Base run at all, or existed in the Base run but was passing its accessibility checks."]}),"\n",(0,t.jsx)(s,{src:"/img/accessibility/core-concepts/branch-review-a11y-new-failed.png",alt:"Cypress Accessibility Branch Review showing two main sections - New Failed Elements and Resolved Elements"}),"\n",(0,t.jsx)(i.p,{children:'Any rules with new failed elements will appear here. There are two ways to explore this list. You can open each rule and choose from he list of Views where a new failed element was detected, or if you click the "View All" link, you will see a full report containing all of the net-new failures in the run, across all rules and views.'}),"\n",(0,t.jsx)(i.p,{children:"Either path will take you to the detailed report, either for a single View or for all View combined. This report works exactly like the main Cypress Accessibility report, with full-page snapshot examples for every violation. The only difference is that all issues that are the same on both runs have been removed, leaving just what's new - either for the specific View you've chosen, or across all views."}),"\n",(0,t.jsx)(s,{src:"/img/accessibility/core-concepts/branch-review-a11y-detail-view.png",alt:"Cypress Accessibility Branch Review showing the detailed diff for a demo contact form. A 'name' field in the contact form is highlighted in red because it is missing a label."}),"\n",(0,t.jsx)(i.h4,{id:"Single-View-diff-vs-whole-run-diff",children:"Single-View diff vs whole-run diff"}),"\n",(0,t.jsx)(i.p,{children:'Each rule has an "All Views" comparison as the first item, and then lists individual Views below that. Depending on the level of detail you are looking for, you can drill into a specific page or component and see the changes in accessibility there, or just look at the combined report.'}),"\n",(0,t.jsx)(i.p,{children:'The combined "All Views" report for a single rule is especially useful if violations tend to move around between pages over time. For example, if there is a popup with an accessibility problem that appears on a random page in every run, it may appear "new" for a View in the Changed run, and "resolved" for the View where it was in the Base run, but in reality your accessibility score is the same and the problem is the same. "All Views" allows you to sidestep any noise of this kind if needed.'}),"\n",(0,t.jsx)(i.h3,{id:"Resolved-elements",children:"Resolved elements"}),"\n",(0,t.jsxs)(i.p,{children:["A ",(0,t.jsx)(i.strong,{children:"resolved element"})," is an element that had a failed accessibility rule in the Base Run, where a matching failure is not found in the Changed run."]}),"\n",(0,t.jsx)(s,{src:"/img/accessibility/core-concepts/branch-review-a11y-resolved-elements.png",alt:"A list of accessibility rules with resolved elements in the new run"}),"\n",(0,t.jsx)(i.p,{children:'Resolved elements are calculated for every rule and View, but are not displayed individually. This is because, as far as the Changed report is concerned, the failures do not exists, so there is not a guarantee the element is still present in the "new" report.'}),"\n",(0,t.jsxs)(i.p,{children:["If you have a use case for seeing the specific elements that are no longer detected to have failures, please reach out to your Cypress representative for further discussion. For the time being the focus of Branch Review is on ",(0,t.jsx)(i.strong,{children:"new problems"})," - we avoid mixing old and new data in the same report to minimize the chances of confusion."]}),"\n",(0,t.jsx)(i.h3,{id:"What-if-there-are-no-changes",children:"What if there are no changes?"}),"\n",(0,t.jsx)(i.p,{children:"If there are no changes, the Accessibility Branch Review report still displays all the sections, and explains that there are no elements that appear to be new or resolved in Changed run:"}),"\n",(0,t.jsx)(s,{src:"/img/accessibility/core-concepts/branch-review-a11y-empty-state.png",alt:"The new and resolved elements sections each showing a message to explain that there are no findings"}),"\n",(0,t.jsx)(i.p,{children:"This means the reports are identical, and that the Changed run has not had any impact on accessibility."}),"\n",(0,t.jsx)(i.h2,{id:"Ensuring-a-good-comparison",children:"Ensuring a good comparison"}),"\n",(0,t.jsxs)(i.p,{children:["The easiest subjects to compare are ",(0,t.jsx)(i.strong,{children:"passing runs"})," that ran ",(0,t.jsx)(i.strong,{children:"similar tests"})," on the ",(0,t.jsx)(i.strong,{children:"similar content"}),". This means that each run visited roughly the same pages and completed the same kinds of workflows. In this situation, any diff in the results is likely the result of changes present in the newer run. This is usually what happens out-of-the box when comparing a pull-request branch with your main branch, for example - assuming the same tests run on both branches."]}),"\n",(0,t.jsx)(i.p,{children:"That said, it still possible and valid to compare runs from different points in time with different sets of test results, as long as you bear in mind all the potential sources of difference between the two runs, which you can evaluate for yourself as you explore the results."}),"\n",(0,t.jsxs)(i.p,{children:["In order to see unified changes for your entire test suite, you need to group all the tests together under a single Cypress run, for each report. Learn more about this in the ",(0,t.jsx)(i.a,{href:"/cloud/features/branch-review#Best-Practices",children:"Branch Review Best Practices documentation"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"Stabilizing-the-comparison",children:"Stabilizing the comparison"}),"\n",(0,t.jsx)(i.p,{children:"On most projects, comparing accessibility reports will work nicely out of the box. But in some cases, configuration is useful to handle dynamic values that might be present in page URLs or element locator. You may also want to take steps to improve the consistency of the elements under test."}),"\n",(0,t.jsx)(i.h3,{id:"Stable-Views",children:"Stable Views"}),"\n",(0,t.jsxs)(i.p,{children:['URLs with dynamic slugs in them can appear as "new" pages in some situations. This behavior can be adjusted with ',(0,t.jsx)(i.a,{href:"/accessibility/configuration/views",children:"View configuration"})," to make sure page names will match across runs by wildcarding parts of the URL as needed."]}),"\n",(0,t.jsxs)(i.p,{children:["Cypress performs this process automatically for certain known patterns. For example, the default behavior is to track a URL like ",(0,t.jsx)(i.code,{children:"https://example.com/products/123"})," as ",(0,t.jsx)(i.code,{children:"https://example.com/products/*"})," so that the underlying product pages are grouped together as one View, and then between runs that View is recognized in a stable way."]}),"\n",(0,t.jsx)(i.p,{children:'If a View appears to be "new", it is identified with a green plus icon, and a tooltip explaining that this View was seen on the Changed run but not on the base run, as seen here in the New Failed Elements section:'}),"\n",(0,t.jsx)(s,{src:"/img/accessibility/core-concepts/added-views.png",alt:"Cypress Accessibility Branch Review showing several added views in a report, with a plus sign beside each one and a tooltip explaining that the view was seen in one report, but not the other."}),"\n",(0,t.jsx)(i.p,{children:"Likewise, if a rule appears to have resolved elements on Views that are simply no longer captured on the Changed run, this is identified in the Resolved Elements section:"}),"\n",(0,t.jsx)(s,{src:"/img/accessibility/core-concepts/removed-views.png",alt:"Cypress Accessibility Branch Review showing several added views in a report, with a plus sign beside each one and a tooltip explaining that the view was seen in one report, but not the other."}),"\n",(0,t.jsx)(i.p,{children:"These changes in Views may be because a new page was actually added to the application, or a new page was reached by testing that wasn't reached before. It will be clear to you if configuration is needed to improve View stability across runs, as you will see unexpected added and removed URLs."}),"\n",(0,t.jsx)(i.h3,{id:"Stable-Elements",children:"Stable Elements"}),"\n",(0,t.jsxs)(i.p,{children:["Cypress stores a string that represents each failed element in a report, determined using a standardized ",(0,t.jsx)(i.a,{href:"/accessibility/core-concepts/element-identification",children:"element identification process"}),". This operates in a different way to the standard Axe-Core\xae element identification algorithm, to support the comparison of runs from different builds of the application, and make use of the testing-related attributes you may already have created in the DOM."]}),"\n",(0,t.jsxs)(i.p,{children:["Where possible, we prioritize known stable locators like ",(0,t.jsx)(i.code,{children:"data-cy"})," or ",(0,t.jsx)(i.code,{children:"data-testid"}),". In some cases the identification strings will contain dynamic values that change on every build of your application, introducing noise in a diff. The element identification behavior is flexible and can be configured to meet your needs and fully avoid dynamic values as identifiers."]}),"\n",(0,t.jsxs)(i.p,{children:["For example, if an element's default locator includes a class like ",(0,t.jsx)(i.code,{children:".css-21kj23"})," in Build A, and a slightly different class like ",(0,t.jsx)(i.code,{children:".css-2309kj"}),' in Build B, it will appear as though there was a "resolved element" and "new violation".']}),"\n",(0,t.jsxs)(i.p,{children:["This behavior is highly customizable so that you can avoid depending on values that don't matter to you, but also you can choose specific attributes that ",(0,t.jsx)(i.em,{children:"do"})," matter for element recognition and get sensible deduplication and matching behavior based on your own goals."]}),"\n",(0,t.jsxs)(i.p,{children:["Learn more about the ",(0,t.jsx)(i.a,{href:"/accessibility/configuration/attributefilters",children:(0,t.jsx)(i.code,{children:"attributeFilters"})})," and ",(0,t.jsx)(i.a,{href:"/accessibility/configuration/significantattributes",children:(0,t.jsx)(i.code,{children:"significantAttributes"})})," configuration available, or reach out to us for any assistance on dialing in the behavior."]}),"\n",(0,t.jsx)(i.h3,{id:"Stable-underlying-reporting-area",children:"Stable underlying reporting area"}),"\n",(0,t.jsx)(i.p,{children:"It's likely that your tests have never been used for always-on accessibility tests before, and while most codebases produce stable results, some projects have inherent differences between runs due to the performance of specific processes during testing."}),"\n",(0,t.jsx)(i.p,{children:"For example, sometimes the test may spend enough time on a page to see a confirmation message after a form is submitted, unless the server response is slow, then the test may finish without rendering the state."}),"\n",(0,t.jsxs)(i.p,{children:["There are different solutions depending on the nature of the issue. If you want to ensure the state is always picked up in Cypress Accessibility, you can add some assertion about that state to your tests. On the other hand, if you do not want to account for this state at all, it can be ignored with ",(0,t.jsx)(i.a,{href:"/accessibility/configuration/elementfilters",children:(0,t.jsx)(i.code,{children:"elementFilters"})})," configuration. Either approach will lead to a more stable branch comparison."]})]})}function d(e={}){const{wrapper:i}={...(0,n.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}function u(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},1151:(e,i,s)=>{s.d(i,{Z:()=>o,a:()=>r});var t=s(7294);const n={},a=t.createContext(n);function r(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);