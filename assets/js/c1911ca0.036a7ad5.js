"use strict";(self.webpackChunkcypress_docusaurus_ts=self.webpackChunkcypress_docusaurus_ts||[]).push([[7385],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=i,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||o;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1189:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={title:"Retry-ability",sidebar_position:40},r=void 0,s={unversionedId:"guides/core-concepts/retry-ability",id:"guides/core-concepts/retry-ability",title:"Retry-ability",description:"What you'll learn",source:"@site/docs/guides/core-concepts/retry-ability.mdx",sourceDirName:"guides/core-concepts",slug:"/guides/core-concepts/retry-ability",permalink:"/cypress-documentation/guides/core-concepts/retry-ability",draft:!1,editUrl:"https://github.com/cypress-io/cypress-documentation/tree/main/docs/guides/core-concepts/retry-ability.mdx",tags:[],version:"current",lastUpdatedAt:1697463939,formattedLastUpdatedAt:"Oct 16, 2023",sidebarPosition:40,frontMatter:{title:"Retry-ability",sidebar_position:40},sidebar:"guides",previous:{title:"Test Isolation",permalink:"/cypress-documentation/guides/core-concepts/test-isolation"},next:{title:"Interacting with Elements",permalink:"/cypress-documentation/guides/core-concepts/interacting-with-elements"}},l={},c=[{value:"Commands, Queries and Assertions",id:"Commands-Queries-and-Assertions",level:2},{value:"Multiple assertions",id:"Multiple-assertions",level:2},{value:"Implicit Assertions",id:"Implicit-Assertions",level:2},{value:"Timeouts",id:"Timeouts",level:2},{value:"Increase time to retry",id:"Increase-time-to-retry",level:3},{value:"Disable retry",id:"Disable-retry",level:3},{value:"Only queries are retried",id:"Only-queries-are-retried",level:2},{value:"Actions should be at the end of chains, not the middle",id:"Actions-should-be-at-the-end-of-chains-not-the-middle",level:3},{value:'<Icon name="exclamation-triangle" color="red" /> Incorrectly chaining commands',id:"Incorrectly-chaining-commands",level:4},{value:'<Icon name="check-circle" color="green" /> Correctly ending chains after an action',id:"Correctly-ending-chains-after-an-action",level:4},{value:'<Icon name="exclamation-triangle" color="red" /> Incorrectly checking if the stub was called',id:"Incorrectly-checking-if-the-stub-was-called",level:4},{value:'<Icon name="check-circle" color="green" /> Correctly waiting for the stub to be called',id:"Correctly-waiting-for-the-stub-to-be-called",level:4},{value:"Use <code>.should()</code> with a callback",id:"Use-should-with-a-callback",level:3},{value:'<Icon name="exclamation-triangle" color="red" /> Incorrectly waiting for values',id:"Incorrectly-waiting-for-values",level:3},{value:'<Icon name="check-circle" color="green" /> Correctly waiting for values',id:"Correctly-waiting-for-values",level:4},{value:"See also",id:"See-also",level:2}],d=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},p=d("Icon"),m=d("DocsImage"),u={toc:c};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("h2",{parentName:"admonition",id:"What-youll-learn"},(0,i.kt)(p,{name:"graduation-cap",mdxType:"Icon"})," What you'll learn"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"How Cypress retries commands and assertions"),(0,i.kt)("li",{parentName:"ul"},"When commands are retried and when they are not"),(0,i.kt)("li",{parentName:"ul"},"How to address some situations of flaky tests"))),(0,i.kt)("p",null,"A core feature of Cypress that assists with testing dynamic web applications is\nretry-ability. Like a good transmission in a car, it usually works without you\nnoticing it. But understanding how it works will help you write faster tests\nwith fewer run-time surprises."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("strong",null,"Test Retries"),(0,i.kt)("p",{parentName:"admonition"},"If you are looking to retry tests a configured number of times when the test\nfails, check out our guide on ",(0,i.kt)("a",{parentName:"p",href:"/guides/guides/test-retries"},"Test Retries"),".")),(0,i.kt)("h2",{id:"Commands-Queries-and-Assertions"},"Commands, Queries and Assertions"),(0,i.kt)("p",null,"While all methods you chain off of ",(0,i.kt)("inlineCode",{parentName:"p"},"cy")," in your Cypress tests are commands, it's\nimportant to understand the different rules by which they operate."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Queries")," link up, retrying the entire chain together."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"}," Assertions")," are a type of query that's specially displayed in the command\nlog."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Non-queries")," only execute once.")),(0,i.kt)("p",null,"For example, there are 5 queries, an action, and 2 assertions in\nthe test below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"it('creates an item', () => {\n  // Non-query commands only execute once.\n  cy.visit('/')\n\n  // The .focused() query and .should() assertion link together,\n  // rerunning until the currently focused element has\n  // the 'new-todo' class\n  cy.focused().should('have.class', 'new-todo')\n\n  // The queries .get() and .find()\n  // link together, forming the subject for\n  // the non-query `.type()`.\n  cy.get('.header').find('.new-todo').type('todo A{enter}')\n\n  // Two queries and an assertion chained together\n  cy.get('.todoapp').find('.todo-list li').should('have.length', 1)\n})\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/guides/core-concepts/cypress-app#Command-Log"},"Command Log")," shows all\ncommands regardless of types, with passing assertions showing in green."),(0,i.kt)(m,{src:"/img/guides/retry-ability/command-assertions.png",alt:"Cypress tests showing commands and assertions",mdxType:"DocsImage"}),(0,i.kt)("p",null,"Let's look at the last chain of commands:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"cy.get('.todoapp') // query\n  .find('.todo-list li') // query\n  .should('have.length', 1) // assertion\n")),(0,i.kt)("p",null,"Because nothing is synchronous in modern web applications, Cypress can't query\nall the DOM elements matching ",(0,i.kt)("inlineCode",{parentName:"p"},".todo-list li")," and check if there is exactly one\nof them. There are many examples of why this would not work well."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"What if the application has not updated the DOM by the time these commands\nrun?"),(0,i.kt)("li",{parentName:"ul"},"What if the application is waiting for its back end to respond before\npopulating the DOM element?"),(0,i.kt)("li",{parentName:"ul"},"What if the application does some intensive computation before showing the\nresults in the DOM?")),(0,i.kt)("p",null,"Thus ",(0,i.kt)("a",{parentName:"p",href:"/api/commands/get"},(0,i.kt)("inlineCode",{parentName:"a"},"cy.get"))," and ",(0,i.kt)("a",{parentName:"p",href:"/api/commands/find"},(0,i.kt)("inlineCode",{parentName:"a"},"cy.find()"))," have to\nbe smarter and expect the application to potentially update. ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.get()")," queries\nthe application's DOM, finds the elements that match the selector, and then\npasses them to ",(0,i.kt)("inlineCode",{parentName:"p"},".find('.todo-list li')"),". ",(0,i.kt)("inlineCode",{parentName:"p"},".find()")," locates a new set of\nelements, and passes them to ",(0,i.kt)("inlineCode",{parentName:"p"},".should()"),". ",(0,i.kt)("inlineCode",{parentName:"p"},".should()")," then asserts on the list\nof found elements (in our case, that it has a length of 1)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u2705 If the assertion passes, then ",(0,i.kt)("inlineCode",{parentName:"li"},".should()")," finishes successfully."),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udea8 If the assertion fails, then Cypress will requery the application's DOM\nagain - starting from the top of the chain of linked queries. It will look for\nelements that match ",(0,i.kt)("inlineCode",{parentName:"li"},".get().find()")," again, and re-run the assertion. If the\nassertion still fails, Cypress continues retrying until the timeout is\nreached.")),(0,i.kt)("p",null,"Retry-ability allows the test to complete each command as soon as the assertion\npasses, without hard-coding waits. If your application takes a few milliseconds\nor even seconds to render each DOM element - no big deal, the test does not have\nto change at all. For example, let's introduce an artificial delay of 3 seconds\nwhen refreshing the application's UI below in an example TodoMVC model code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"app.TodoModel.prototype.addTodo = function (title) {\n  this.todos = this.todos.concat({\n    id: Utils.uuid(),\n    title: title,\n    completed: false,\n  })\n\n  // let's trigger the UI to render after 3 seconds\n  setTimeout(() => {\n    this.inform()\n  }, 3000)\n}\n")),(0,i.kt)("p",null,"The test still passes! ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.get('.todo-list')")," passes immediately - the\n",(0,i.kt)("inlineCode",{parentName:"p"},"todo-list")," exists - but ",(0,i.kt)("inlineCode",{parentName:"p"},".should('have.length', 1)")," shows the spinning\nindicator, meaning Cypress is still waiting for the assertion to pass."),(0,i.kt)(m,{src:"/img/guides/retry-ability/retry-assertion.gif",alt:"Retrying assertion",mdxType:"DocsImage"}),(0,i.kt)("p",null,"Within a few milliseconds after the DOM updates, the linked queries\n",(0,i.kt)("inlineCode",{parentName:"p"},".get().find()")," locate an element and ",(0,i.kt)("inlineCode",{parentName:"p"},".should('have.length', 1)")," passes."),(0,i.kt)("h2",{id:"Multiple-assertions"},"Multiple assertions"),(0,i.kt)("p",null,"Queries and assertions are always executed in order, and always retry 'from the\ntop'. If you have multiple assertions, Cypress will retry until each passes\nbefore moving on to the next one."),(0,i.kt)("p",null,"For example, the following test has ",(0,i.kt)("a",{parentName:"p",href:"/api/commands/should"},(0,i.kt)("inlineCode",{parentName:"a"},".should()"))," and\n",(0,i.kt)("a",{parentName:"p",href:"/api/commands/and"},(0,i.kt)("inlineCode",{parentName:"a"},".and()"))," assertions. ",(0,i.kt)("inlineCode",{parentName:"p"},".and()")," is an alias of the\n",(0,i.kt)("inlineCode",{parentName:"p"},".should()")," command, so the second assertion is really a custom callback\nassertion in the form of the ",(0,i.kt)("a",{parentName:"p",href:"/api/commands/should#Function"},(0,i.kt)("inlineCode",{parentName:"a"},".should(cb)")),"\nfunction with 2 ",(0,i.kt)("a",{parentName:"p",href:"/guides/references/assertions#BDD-Assertions"},(0,i.kt)("inlineCode",{parentName:"a"},"expect")),"\nassertions inside of it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"it('creates two items', () => {\n  cy.visit('/')\n\n  cy.get('.new-todo').type('todo A{enter}')\n  cy.get('.new-todo').type('todo B{enter}')\n\n  cy.get('.todo-list li') // query\n    .should('have.length', 2) // assertion\n    .and(($li) => {\n      // 2 mocha assertions inside of the .and() assertion\n      expect($li.get(0).textContent, 'first item').to.equal('todo a')\n      expect($li.get(1).textContent, 'second item').to.equal('todo B')\n    })\n})\n")),(0,i.kt)("p",null,"Because the first expect statement\n(",(0,i.kt)("inlineCode",{parentName:"p"},"expect($li.get(0).textContent, 'first item').to.equal('todo a')"),") fails, the\nsecond statement is never reached. The ",(0,i.kt)("inlineCode",{parentName:"p"},".and()")," command fails after timing out,\nand the Command Log correctly shows that the first encountered assertion\n",(0,i.kt)("inlineCode",{parentName:"p"},"should('have.length', 2)"),' passed, but\nthe "first item" assertion failed.'),(0,i.kt)(m,{src:"/img/guides/retry-ability/second-assertion-fails.gif",alt:"Retrying multiple assertions",mdxType:"DocsImage"}),(0,i.kt)("h2",{id:"Implicit-Assertions"},"Implicit Assertions"),(0,i.kt)("p",null,"Often a Cypress command has built-in assertions that will cause the command to\nbe retried until they pass. For example, the ",(0,i.kt)("a",{parentName:"p",href:"/api/commands/eq"},(0,i.kt)("inlineCode",{parentName:"a"},".eq()"))," query\nwill be retried even without any attached assertions until it finds an element\nwith the given index."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"cy.get('.todo-list li') // query\n  .should('have.length', 2) // assertion\n  .eq(3) // query\n")),(0,i.kt)(m,{src:"/img/guides/retry-ability/eq.gif",alt:"Retrying built-in assertion",mdxType:"DocsImage"}),(0,i.kt)("p",null,"Only queries can be retried, but most other commands still have built-in\n",(0,i.kt)("em",{parentName:"p"},"waiting"),' and assertions. For example, as described in the "Assertions" section\nof ',(0,i.kt)("a",{parentName:"p",href:"/api/commands/click"},".click()"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"click()")," action command waits to click\nuntil the element becomes\n",(0,i.kt)("a",{parentName:"p",href:"/guides/core-concepts/interacting-with-elements#Actionability"},"actionable"),",\nincluding re-running the query chain leading up to it in case the page updates\nwhile we're waiting."),(0,i.kt)("p",null,"Cypress tries to act like a human user would using the browser."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Can a user click on the element?"),(0,i.kt)("li",{parentName:"ul"},"Is the element invisible?"),(0,i.kt)("li",{parentName:"ul"},"Is the element behind another element?"),(0,i.kt)("li",{parentName:"ul"},"Does the element have the ",(0,i.kt)("inlineCode",{parentName:"li"},"disabled")," attribute?")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/guides/core-concepts/interacting-with-elements"},"Action commands")," - such as\n",(0,i.kt)("inlineCode",{parentName:"p"},".click()")," - automatically wait until multiple built-in assertions like these\npass, and then it will attempt the action once."),(0,i.kt)("h2",{id:"Timeouts"},"Timeouts"),(0,i.kt)("p",null,"By default each command that retries does so for up to 4 seconds - the\n",(0,i.kt)("a",{parentName:"p",href:"/guides/references/configuration#Timeouts"},(0,i.kt)("inlineCode",{parentName:"a"},"defaultCommandTimeout"))," setting."),(0,i.kt)("h3",{id:"Increase-time-to-retry"},"Increase time to retry"),(0,i.kt)("p",null,"You can change the default timeout for ",(0,i.kt)("em",{parentName:"p"},"all commands"),". See\n",(0,i.kt)("a",{parentName:"p",href:"/guides/references/configuration#Overriding-Options"},"Configuration: Overriding Options"),"\nfor examples of overriding this option."),(0,i.kt)("p",null,"For example, to set the default command timeout to 10 seconds via the command\nline:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cypress run --config defaultCommandTimeout=10000\n")),(0,i.kt)("p",null,"We do not recommend changing the command timeout globally. Instead, pass the\nindividual command's ",(0,i.kt)("inlineCode",{parentName:"p"},"{ timeout: ms }")," option to retry for a different period of\ntime. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// we've modified the timeout which affects default + added assertions\ncy.get('[data-testid=\"mobile-nav\"]', { timeout: 10000 })\n  .should('be.visible')\n  .and('contain', 'Home')\n")),(0,i.kt)("p",null,"Cypress will retry for up to 10 seconds to find a visible element with\n",(0,i.kt)("inlineCode",{parentName:"p"},"data-testid")," attribute ",(0,i.kt)("inlineCode",{parentName:"p"},"mobile-nav"),' with text containing "Home". For more\nexamples, read the\n',(0,i.kt)("a",{parentName:"p",href:"/guides/core-concepts/introduction-to-cypress#Timeouts"},"Timeouts"),' section in\nthe "Introduction to Cypress" guide.'),(0,i.kt)("h3",{id:"Disable-retry"},"Disable retry"),(0,i.kt)("p",null,"Overriding the timeout to ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," will essentially disable retrying the query, since\nit will spend 0 milliseconds retrying."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// check synchronously that the element does not exist (no retry)\n// for example just after a server-side render\ncy.get('[data-testid=\"ssr-error\"]', { timeout: 0 }).should('not.exist')\n")),(0,i.kt)("h2",{id:"Only-queries-are-retried"},"Only queries are retried"),(0,i.kt)("p",null,"Any command that isn't a query, such as ",(0,i.kt)("inlineCode",{parentName:"p"},".click()"),', will not "chain together" to\nform the subject for later commands the way queries do. Cypress will retry any\nqueries ',(0,i.kt)("em",{parentName:"p"},"leading up to")," a command, and retry any assertions ",(0,i.kt)("em",{parentName:"p"},"after")," a command,\nbut commands themselves only execute once. After they've executed, nothing\nleading up to them will retry."),(0,i.kt)("p",null,"Most commands are not retried because they could potentially change the state of\nthe application under test. For example, Cypress will not retry the\n",(0,i.kt)("a",{parentName:"p",href:"/api/commands/click"},".click()")," action command, because it could change\nsomething in the application. After the click occurs, Cypress will also not\nre-run any queries before ",(0,i.kt)("inlineCode",{parentName:"p"},".click()"),"."),(0,i.kt)("h3",{id:"Actions-should-be-at-the-end-of-chains-not-the-middle"},"Actions should be at the end of chains, not the middle"),(0,i.kt)("p",null,"The following test might have problems if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Your JS framework re-rendered asynchronously"),(0,i.kt)("li",{parentName:"ul"},"Your app code reacted to an event firing and removed the element")),(0,i.kt)("h4",{id:"Incorrectly-chaining-commands"},(0,i.kt)(p,{name:"exclamation-triangle",color:"red",mdxType:"Icon"})," Incorrectly chaining commands"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"cy.get('.new-todo')\n  .type('todo A{enter}') // action\n  .type('todo B{enter}') // action after another action - bad\n  .should('have.class', 'active') // assertion after an action - bad\n")),(0,i.kt)("h4",{id:"Correctly-ending-chains-after-an-action"},(0,i.kt)(p,{name:"check-circle",color:"green",mdxType:"Icon"})," Correctly ending chains after an action"),(0,i.kt)("p",null,"To avoid these issues entirely, it is better to split up the above chain of\ncommands."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"cy.get('.new-todo').type('todo A{enter}')\ncy.get('.new-todo').type('todo B{enter}')\ncy.get('.new-todo').should('have.class', 'active')\n")),(0,i.kt)("p",null,"Writing your tests in this way will help you avoid issues where the page\nrerenders in the middle of your test and Cypress loses track of which elements\nit's supposed to be operating or asserting on. Aliases -\n",(0,i.kt)("a",{parentName:"p",href:"/api/commands/as"},(0,i.kt)("inlineCode",{parentName:"a"},"cy.as()"))," - can help make this pattern less intrusive."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"cy.get('.new-todo').as('new')\n\ncy.get('@new').type('todo A{enter}')\ncy.get('@new').type('todo B{enter}')\ncy.get('@new').should('have.class', 'active')\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Very rarely you may want to retry a command like ",(0,i.kt)("inlineCode",{parentName:"p"},".click()"),". We describe one\ncase like that where the event listeners are attached to a modal popup only\nafter a delay, thus causing default events fired during ",(0,i.kt)("inlineCode",{parentName:"p"},".click()"),' to not\nregister. In this special case you may want to "keep clicking" until the event\nregisters, and the dialog disappears. Read about it in the\n',(0,i.kt)("a",{parentName:"p",href:"https://www.cypress.io/blog/2019/01/22/when-can-the-test-click/"},"When Can the Test Click?"),"\nblog post."),(0,i.kt)("p",{parentName:"admonition"},"Because of the implicit assertions built into every command, and action commands\nin particular, you should rarely need this pattern.")),(0,i.kt)("p",null,"As another example, when confirming that the button component invokes the\n",(0,i.kt)("inlineCode",{parentName:"p"},"click")," prop testing with the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cypress-io/cypress/tree/develop/npm/react"},"cypress/react"),"\nmounting library, the following test might or might not work:"),(0,i.kt)("h4",{id:"Incorrectly-checking-if-the-stub-was-called"},(0,i.kt)(p,{name:"exclamation-triangle",color:"red",mdxType:"Icon"})," Incorrectly checking if the stub was called"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const Clicker = ({ click }) => (\n  <div>\n    <button onClick={click}>Click me</button>\n  </div>\n)\n\nit('calls the click prop twice', () => {\n  const onClick = cy.stub()\n  cy.mount(<Clicker click={onClick} />)\n  cy.get('button')\n    .click()\n    .click()\n    .then(() => {\n      // works in this case, but not recommended\n      // because .click() and .then() do not retry\n      expect(onClick).to.be.calledTwice\n    })\n})\n")),(0,i.kt)("p",null,"The above example will fail if the component calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"click")," prop after a\ndelay."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const Clicker = ({ click }) => (\n  <div>\n    <button onClick={() => setTimeout(click, 500)}>Click me</button>\n  </div>\n)\n")),(0,i.kt)(m,{src:"/img/guides/retry-ability/delay-click.png",alt:"Expect fails the test without waiting for the delayed stub",mdxType:"DocsImage"}),(0,i.kt)("p",null,"The test finishes before the component calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"click")," prop twice, and without\nretrying the assertion ",(0,i.kt)("inlineCode",{parentName:"p"},"expect(onClick).to.be.calledTwice"),"."),(0,i.kt)("p",null,"It could also fail if React or another JavaScript library decided to rerender\nthe DOM between clicks."),(0,i.kt)("h4",{id:"Correctly-waiting-for-the-stub-to-be-called"},(0,i.kt)(p,{name:"check-circle",color:"green",mdxType:"Icon"})," Correctly waiting for the stub to be called"),(0,i.kt)("p",null,"We recommend aliasing the stub using the ",(0,i.kt)("a",{parentName:"p",href:"/api/commands/as"},(0,i.kt)("inlineCode",{parentName:"a"},".as"))," command and\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.get('@alias')")," to run assertions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"it('calls the click prop', () => {\n  const onClick = cy.stub().as('clicker')\n\n  cy.mount(<Clicker click={onClick} />)\n  // Good practice \ud83d\udca1: Don't chain anything off of commands\n  cy.get('button').click()\n  cy.get('button').click()\n\n  // Good practice \ud83d\udca1: Reference the stub with an alias\n  cy.get('@clicker').should('have.been.calledTwice')\n})\n")),(0,i.kt)(m,{src:"/img/guides/retry-ability/click-twice.gif",alt:"Retrying the assertions using a stub alias",mdxType:"DocsImage"}),(0,i.kt)("h3",{id:"Use-should-with-a-callback"},"Use ",(0,i.kt)("inlineCode",{parentName:"h3"},".should()")," with a callback"),(0,i.kt)("p",null,"If you are using commands, but need to retry the entire chain, consider\nrewriting the commands into a\n",(0,i.kt)("a",{parentName:"p",href:"/api/commands/should#Function"},".should(callbackFn)"),"."),(0,i.kt)("p",null,"Below is an example where the number value is set after a delay:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<div class="random-number-example">\n  Random number: <span id="random-number">\ud83c\udf81</span>\n</div>\n<script>\n  const el = document.getElementById(\'random-number\')\n  setTimeout(() => {\n    el.innerText = Math.floor(Math.random() * 10 + 1)\n  }, 1500)\n<\/script>\n')),(0,i.kt)(m,{src:"/img/guides/retry-ability/random-number.gif",alt:"Random number",mdxType:"DocsImage"}),(0,i.kt)("h3",{id:"Incorrectly-waiting-for-values"},(0,i.kt)(p,{name:"exclamation-triangle",color:"red",mdxType:"Icon"})," Incorrectly waiting for values"),(0,i.kt)("p",null,"You may want to write a test like below, to test that the number is between 1\nand 10, although ",(0,i.kt)("strong",{parentName:"p"},"this will not work as intended"),". The test yields the\nfollowing values, noted in the comments, before failing."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// WRONG: this test will not work as intended\ncy.get('[data-testid=\"random-number\"]') // <div>\ud83c\udf81</div>\n  .invoke('text') // \"\ud83c\udf81\"\n  .then(parseFloat) // NaN\n  .should('be.gte', 1) // fails\n  .and('be.lte', 10) // never evaluates\n")),(0,i.kt)("p",null,"Unfortunately, the ",(0,i.kt)("a",{parentName:"p",href:"/api/commands/then"},".then()")," command breaks the chain of\nqueries - nothing before it (such as fetching the text of the element) re-runs."),(0,i.kt)(m,{src:"/img/guides/retry-ability/random-number-first-attempt.png",alt:"First attempt at writing the test",mdxType:"DocsImage"}),(0,i.kt)("h4",{id:"Correctly-waiting-for-values"},(0,i.kt)(p,{name:"check-circle",color:"green",mdxType:"Icon"})," Correctly waiting for values"),(0,i.kt)("p",null,"We need to retry getting the element, invoking the ",(0,i.kt)("inlineCode",{parentName:"p"},"text()")," method, calling the\n",(0,i.kt)("inlineCode",{parentName:"p"},"parseFloat")," function and running the ",(0,i.kt)("inlineCode",{parentName:"p"},"gte")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lte")," assertions. We can achieve\nthis using the ",(0,i.kt)("inlineCode",{parentName:"p"},".should(callbackFn)"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"cy.get('[data-testid=\"random-number\"]').should(($div) => {\n  // all the code inside here will retry\n  // until it passes or times out\n  const n = parseFloat($div.text())\n\n  expect(n).to.be.gte(1).and.be.lte(10)\n})\n")),(0,i.kt)("p",null,"The above test retries getting the element and invoking the text of the element\nto get the number. When the number is finally set in the application, then the\n",(0,i.kt)("inlineCode",{parentName:"p"},"gte")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lte")," assertions pass and the test passes."),(0,i.kt)(m,{src:"/img/guides/retry-ability/random-number-callback.gif",alt:"Random number using callback",mdxType:"DocsImage"}),(0,i.kt)("h2",{id:"See-also"},"See also"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Read our blog posts about fighting\n",(0,i.kt)("a",{parentName:"li",href:"https://cypress.io/blog/tag/flake/"},"the test flake"),"."),(0,i.kt)("li",{parentName:"ul"},"You can add retry-ability to your own\n",(0,i.kt)("a",{parentName:"li",href:"/api/cypress-api/custom-commands"},"custom commands")," and queries."),(0,i.kt)("li",{parentName:"ul"},"You can retry any function with attached assertions using the 3rd party\nplugins ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/NicholasBoll/cypress-pipe"},"cypress-pipe")," and\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/NoriSte/cypress-wait-until"},"cypress-wait-until"),"."),(0,i.kt)("li",{parentName:"ul"},"3rd party plugin\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/bahmutov/cypress-recurse"},"cypress-recurse")," can be used to\nimplement the\n",(0,i.kt)("a",{parentName:"li",href:"https://glebbahmutov.com/blog/canvas-testing/"},"visual testing with retry-ability for canvas elements")),(0,i.kt)("li",{parentName:"ul"},"To learn how to enable Cypress' test retries functionality, which retries\ntests that fail, check out our official guide on\n",(0,i.kt)("a",{parentName:"li",href:"/guides/guides/test-retries"},"Test Retries"),".")))}h.isMDXComponent=!0}}]);