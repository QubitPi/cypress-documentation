"use strict";(self.webpackChunkcypress_docusaurus_ts=self.webpackChunkcypress_docusaurus_ts||[]).push([[8067],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(n),m=s,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,r=new Array(o);r[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:s,r[1]=i;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3844:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(7462),s=(n(7294),n(3905));const o={title:"Variables and Aliases",sidebar_position:60},r=void 0,i={unversionedId:"guides/core-concepts/variables-and-aliases",id:"guides/core-concepts/variables-and-aliases",title:"Variables and Aliases",description:"What you'll learn",source:"@site/docs/guides/core-concepts/variables-and-aliases.mdx",sourceDirName:"guides/core-concepts",slug:"/guides/core-concepts/variables-and-aliases",permalink:"/cypress-documentation/guides/core-concepts/variables-and-aliases",draft:!1,editUrl:"https://github.com/cypress-io/cypress-documentation/tree/main/docs/guides/core-concepts/variables-and-aliases.mdx",tags:[],version:"current",lastUpdatedAt:1697463939,formattedLastUpdatedAt:"Oct 16, 2023",sidebarPosition:60,frontMatter:{title:"Variables and Aliases",sidebar_position:60},sidebar:"guides",previous:{title:"Interacting with Elements",permalink:"/cypress-documentation/guides/core-concepts/interacting-with-elements"},next:{title:"Conditional Testing",permalink:"/cypress-documentation/guides/core-concepts/conditional-testing"}},l={},c=[{value:"Return Values",id:"Return-Values",level:2},{value:"Closures",id:"Closures",level:3},{value:"Debugging",id:"Debugging",level:3},{value:"Variables",id:"Variables",level:3},{value:"Aliases",id:"Aliases",level:2},{value:"Sharing Context",id:"Sharing-Context",level:3},{value:"Accessing Fixtures:",id:"Accessing-Fixtures",level:4},{value:"Avoiding the use of <code>this</code>",id:"Avoiding-the-use-of-this",level:4},{value:"Elements",id:"Elements",level:3},{value:"Stale Elements:",id:"Stale-Elements",level:4},{value:"Intercepts",id:"Intercepts",level:3},{value:"Requests",id:"Requests",level:3},{value:"Aliases are reset before each test",id:"Aliases-are-reset-before-each-test",level:3},{value:"See also",id:"See-also",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,s.kt)("div",t)},p=u("Icon"),d=u("DocsImage"),m={toc:c};function h(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("h2",{parentName:"admonition",id:"What-youll-learn"},(0,s.kt)(p,{name:"graduation-cap",mdxType:"Icon"})," What you'll learn"),(0,s.kt)("ul",{parentName:"admonition"},(0,s.kt)("li",{parentName:"ul"},"How to deal with async commands"),(0,s.kt)("li",{parentName:"ul"},"What Aliases are and how they simplify your code"),(0,s.kt)("li",{parentName:"ul"},"Why you rarely need to use variables with Cypress"),(0,s.kt)("li",{parentName:"ul"},"How to use Aliases for objects, elements and routes"))),(0,s.kt)("h2",{id:"Return-Values"},"Return Values"),(0,s.kt)("p",null,"New users to Cypress may initially find it challenging to work with the\nasynchronous nature of our APIs."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("strong",null,"Do not worry!"),(0,s.kt)("p",{parentName:"admonition"},"There are many ways to reference, compare and utilize the objects that Cypress\ncommands yield you."),(0,s.kt)("p",{parentName:"admonition"},"Once you get the hang of async code you'll realize you can do everything you\ncould do synchronously, without your code doing any backflips."),(0,s.kt)("p",{parentName:"admonition"},"This guide explores many common patterns for writing good Cypress code that can\nhandle even the most complex situations.")),(0,s.kt)("p",null,"Asynchronous APIs are here to stay in JavaScript. They are found everywhere in\nmodern code. In fact, most new browser APIs are asynchronous and many core Node\nmodules are asynchronous as well."),(0,s.kt)("p",null,"The patterns we'll explore below are useful in and outside of Cypress."),(0,s.kt)("p",null,"The first and most important concept you should recognize is..."),(0,s.kt)("admonition",{type:"danger"},(0,s.kt)("strong",null,"Return Values"),(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("strong",{parentName:"p"},"You cannot assign or work with the return values")," of any Cypress command.\nCommands are enqueued and run asynchronously.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// this won't work the way you think it does\nconst button = cy.get('button')\nconst form = cy.get('form')\n\nbutton.click()\n")),(0,s.kt)("h3",{id:"Closures"},"Closures"),(0,s.kt)("p",null,"To access what each Cypress command yields you use\n",(0,s.kt)("a",{parentName:"p",href:"/api/commands/then"},(0,s.kt)("inlineCode",{parentName:"a"},".then()")),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"cy.get('button').then(($btn) => {\n  // $btn is the object that the previous\n  // command yielded us\n})\n")),(0,s.kt)("p",null,"If you're familiar with\n",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"},"native Promises"),"\nthe Cypress ",(0,s.kt)("inlineCode",{parentName:"p"},".then()")," works similarly. You can continue to nest more Cypress\ncommands inside of the ",(0,s.kt)("inlineCode",{parentName:"p"},".then()"),"."),(0,s.kt)("p",null,"Each nested command has access to the work done in previous commands. This ends\nup reading very nicely."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"cy.get('button').then(($btn) => {\n\n  // store the button's text\n  const txt = $btn.text()\n\n  // submit a form\n  cy.get('form').submit()\n\n  // compare the two buttons' text\n  // and make sure they are different\n  cy.get('button').should(($btn2) => {\n    expect($btn2.text()).not.to.eq(txt)\n  })\n})\n\n// these commands run after all of the\n// other previous commands have finished\ncy.get(...).find(...).should(...)\n")),(0,s.kt)("p",null,"The commands outside of the ",(0,s.kt)("inlineCode",{parentName:"p"},".then()")," will not run until all of the nested\ncommands finish."),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("p",{parentName:"admonition"},"By using callback functions we've created a\n",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"},"closure"),".\nClosures enable us to keep references around to refer to work done in previous\ncommands.")),(0,s.kt)("h3",{id:"Debugging"},"Debugging"),(0,s.kt)("p",null,"Using ",(0,s.kt)("inlineCode",{parentName:"p"},".then()")," functions is an excellent opportunity to use\n",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger"},(0,s.kt)("inlineCode",{parentName:"a"},"debugger")),".\nThis can help you understand the order in which commands are run. This also\nenables you to inspect the objects that Cypress yields you in each command."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"cy.get('button').then(($btn) => {\n  // inspect $btn <object>\n  debugger\n\n  cy.get('[data-testid=\"countries\"]')\n    .select('USA')\n    .then(($select) => {\n      // inspect $select <object>\n      debugger\n\n      cy.clock().then(($clock) => {\n        // inspect $clock <object>\n        debugger\n\n        $btn // is still available\n        $select // is still available too\n      })\n    })\n})\n")),(0,s.kt)("h3",{id:"Variables"},"Variables"),(0,s.kt)("p",null,"Typically in Cypress you hardly need to ever use ",(0,s.kt)("inlineCode",{parentName:"p"},"const"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"let"),", or ",(0,s.kt)("inlineCode",{parentName:"p"},"var"),". When\nusing closures you'll always have access to the objects that were yielded to you\nwithout assigning them."),(0,s.kt)("p",null,"The one exception to this rule is when you are dealing with mutable objects\n(that change state). When things change state you often want to compare an\nobject's previous value to the next value."),(0,s.kt)("p",null,"Here's a great use case for a ",(0,s.kt)("inlineCode",{parentName:"p"},"const"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<button>increment</button>\n\nyou clicked button <span data-testid="num">0</span> times\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// app code\nlet count = 0\n\n$('button').on('click', () => {\n  $('[data-testid=\"num\"]').text((count += 1))\n})\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// cypress test code\ncy.get('[data-testid=\"num\"]').then(($span) => {\n  // capture what num is right now\n  const num1 = parseFloat($span.text())\n\n  cy.get('button')\n    .click()\n    .then(() => {\n      // now capture it again\n      const num2 = parseFloat($span.text())\n\n      // make sure it's what we expected\n      expect(num2).to.eq(num1 + 1)\n    })\n})\n")),(0,s.kt)("p",null,"The reason for using ",(0,s.kt)("inlineCode",{parentName:"p"},"const")," is because the ",(0,s.kt)("inlineCode",{parentName:"p"},"$span")," object is mutable. Whenever\nyou have mutable objects and you're trying to compare them, you'll need to store\ntheir values. Using ",(0,s.kt)("inlineCode",{parentName:"p"},"const")," is a perfect way to do that."),(0,s.kt)("h2",{id:"Aliases"},"Aliases"),(0,s.kt)("p",null,"Using ",(0,s.kt)("inlineCode",{parentName:"p"},".then()")," callback functions to access the previous command values is\ngreat","\u2014","but what happens when you're running code in hooks like ",(0,s.kt)("inlineCode",{parentName:"p"},"before")," or\n",(0,s.kt)("inlineCode",{parentName:"p"},"beforeEach"),"?"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"beforeEach(() => {\n  cy.get('button').then(($btn) => {\n    const text = $btn.text()\n  })\n})\n\nit('does not have access to text', () => {\n  // how do we get access to text ?!?!\n})\n")),(0,s.kt)("p",null,"How will we get access to ",(0,s.kt)("inlineCode",{parentName:"p"},"text"),"?"),(0,s.kt)("p",null,"We could make our code do some ugly backflips using ",(0,s.kt)("inlineCode",{parentName:"p"},"let")," to get access to it."),(0,s.kt)("admonition",{type:"danger"},(0,s.kt)("strong",null,"Do not do this"),(0,s.kt)("p",{parentName:"admonition"},"This code below is just for demonstration.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"describe('a suite', () => {\n  // this creates a closure around\n  // 'text' so we can access it\n  let text\n\n  beforeEach(() => {\n    cy.get('button').then(($btn) => {\n      // redefine text reference\n      text = $btn.text()\n    })\n  })\n\n  it('does have access to text', () => {\n    // now text is available to us\n    // but this is not a great solution :(\n    text\n  })\n})\n")),(0,s.kt)("p",null,"Fortunately, you don't have to make your code do backflips. With Cypress, we can\nbetter handle these situations."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("strong",null,"Introducing Aliases"),(0,s.kt)("p",{parentName:"admonition"},"Aliases are a powerful construct in Cypress that have many uses. We'll explore\neach of their capabilities below."),(0,s.kt)("p",{parentName:"admonition"},"At first, we'll use them to share objects between your hooks and your tests.")),(0,s.kt)("h3",{id:"Sharing-Context"},"Sharing Context"),(0,s.kt)("p",null,"Sharing context is the simplest way to use aliases."),(0,s.kt)("p",null,"To alias something you'd like to share use the ",(0,s.kt)("a",{parentName:"p",href:"/api/commands/as"},(0,s.kt)("inlineCode",{parentName:"a"},".as()")),"\ncommand."),(0,s.kt)("p",null,"Let's look at our previous example with aliases."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"beforeEach(() => {\n  // alias the $btn.text() as 'text'\n  cy.get('button').invoke('text').as('text')\n})\n\nit('has access to text', function () {\n  this.text // is now available\n})\n")),(0,s.kt)("p",null,"Under the hood, aliasing basic objects and primitives utilizes Mocha's shared\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/mochajs/mocha/wiki/Shared-Behaviours"},(0,s.kt)("inlineCode",{parentName:"a"},"context"))," object:\nthat is, aliases are available as ",(0,s.kt)("inlineCode",{parentName:"p"},"this.*"),"."),(0,s.kt)("p",null,"Mocha automatically shares contexts for us across all applicable hooks for each\ntest. Additionally these aliases and properties are automatically cleaned up\nafter each test."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"describe('parent', () => {\n  beforeEach(() => {\n    cy.wrap('one').as('a')\n  })\n\n  context('child', () => {\n    beforeEach(() => {\n      cy.wrap('two').as('b')\n    })\n\n    describe('grandchild', () => {\n      beforeEach(() => {\n        cy.wrap('three').as('c')\n      })\n\n      it('can access all aliases as properties', function () {\n        expect(this.a).to.eq('one') // true\n        expect(this.b).to.eq('two') // true\n        expect(this.c).to.eq('three') // true\n      })\n    })\n  })\n})\n")),(0,s.kt)("h4",{id:"Accessing-Fixtures"},"Accessing Fixtures:"),(0,s.kt)("p",null,"The most common use case for sharing context is when dealing with\n",(0,s.kt)("a",{parentName:"p",href:"/api/commands/fixture"},(0,s.kt)("inlineCode",{parentName:"a"},"cy.fixture()")),"."),(0,s.kt)("p",null,"Often times you may load a fixture in a ",(0,s.kt)("inlineCode",{parentName:"p"},"beforeEach")," hook but want to utilize\nthe values in your tests."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"beforeEach(() => {\n  // alias the users fixtures\n  cy.fixture('users.json').as('users')\n})\n\nit('utilize users in some way', function () {\n  // access the users property\n  const user = this.users[0]\n\n  // make sure the header contains the first\n  // user's name\n  cy.get('header').should('contain', user.name)\n})\n")),(0,s.kt)("admonition",{type:"danger"},(0,s.kt)("strong",null,"Watch out for async commands"),(0,s.kt)("p",{parentName:"admonition"},"Do not forget that ",(0,s.kt)("strong",{parentName:"p"},"Cypress commands are async"),"!"),(0,s.kt)("p",{parentName:"admonition"},"You cannot use a ",(0,s.kt)("inlineCode",{parentName:"p"},"this.*")," reference until the ",(0,s.kt)("inlineCode",{parentName:"p"},".as()")," command runs.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"it('is not using aliases correctly', function () {\n  cy.fixture('users.json').as('users')\n\n  // nope this won't work\n  //\n  // this.users is not defined\n  // because the 'as' command has only\n  // been enqueued - it has not run yet\n  const user = this.users[0]\n})\n")),(0,s.kt)("p",null,"The same principles we introduced before apply to this situation. If you want to\naccess what a command yields you have to do it in a closure using a\n",(0,s.kt)("a",{parentName:"p",href:"/api/commands/then"},(0,s.kt)("inlineCode",{parentName:"a"},".then()")),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// yup all good\ncy.fixture('users.json').then((users) => {\n  // now we can avoid the alias altogether\n  // and use a callback function\n  const user = users[0]\n\n  // passes\n  cy.get('header').should('contain', user.name)\n})\n")),(0,s.kt)("h4",{id:"Avoiding-the-use-of-this"},"Avoiding the use of ",(0,s.kt)("inlineCode",{parentName:"h4"},"this")),(0,s.kt)("admonition",{type:"caution"},(0,s.kt)("strong",null,"Arrow Functions"),(0,s.kt)("p",{parentName:"admonition"},"Accessing aliases as properties with ",(0,s.kt)("inlineCode",{parentName:"p"},"this.*")," will not work if you use\n",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"},"arrow functions"),"\nfor your tests or hooks."),(0,s.kt)("p",{parentName:"admonition"},"This is why all of our examples use the regular ",(0,s.kt)("inlineCode",{parentName:"p"},"function () {}"),' syntax as\nopposed to the lambda "fat arrow" syntax ',(0,s.kt)("inlineCode",{parentName:"p"},"() => {}"),".")),(0,s.kt)("p",null,"Instead of using the ",(0,s.kt)("inlineCode",{parentName:"p"},"this.*")," syntax, there is another way to access aliases."),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/commands/get"},(0,s.kt)("inlineCode",{parentName:"a"},"cy.get()"))," command is capable of accessing aliases with\na special syntax using the ",(0,s.kt)("inlineCode",{parentName:"p"},"@")," character:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"beforeEach(() => {\n  // alias the users fixtures\n  cy.fixture('users.json').as('users')\n})\n\nit('utilize users in some way', function () {\n  // use the special '@' syntax to access aliases\n  // which avoids the use of 'this'\n  cy.get('@users').then((users) => {\n    // access the users argument\n    const user = users[0]\n\n    // make sure the header contains the first\n    // user's name\n    cy.get('header').should('contain', user.name)\n  })\n})\n")),(0,s.kt)("p",null,"By using ",(0,s.kt)("a",{parentName:"p",href:"/api/commands/get"},(0,s.kt)("inlineCode",{parentName:"a"},"cy.get()"))," we avoid the use of ",(0,s.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,s.kt)("p",null,"Keep in mind that there are use cases for both approaches because they have one\nmajor difference."),(0,s.kt)("p",null,"When using ",(0,s.kt)("inlineCode",{parentName:"p"},"this.users"),", it is stored on the context when it is first evaluated.\nBut when using ",(0,s.kt)("inlineCode",{parentName:"p"},"cy.get('@users')"),", any queries are re-evaluated every time the\nalias is accessed."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"const favorites = { color: 'blue' }\n\ncy.wrap(favorites).its('color').as('favoriteColor')\n\ncy.then(function () {\n  favorites.color = 'red'\n})\n\ncy.get('@favoriteColor').then(function (aliasValue) {\n  expect(aliasValue).to.eql('red')\n\n  expect(this.favoriteColor).to.eql('blue')\n})\n")),(0,s.kt)("p",null,"In the second ",(0,s.kt)("inlineCode",{parentName:"p"},".then()")," block, ",(0,s.kt)("inlineCode",{parentName:"p"},"cy.get('@favoriteColor')")," runs\n",(0,s.kt)("inlineCode",{parentName:"p"},"cy.wrap(favorites).its('color')")," fresh each time, but ",(0,s.kt)("inlineCode",{parentName:"p"},"this.favoriteColor")," was set when\nthe alias was first stored, back when our favorite color was blue."),(0,s.kt)("h3",{id:"Elements"},"Elements"),(0,s.kt)("p",null,"Aliases have other special characteristics when being used with DOM elements."),(0,s.kt)("p",null,"After you alias DOM elements, you can then later access them for reuse."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"// alias all of the tr's found in the table as 'rows'\ncy.get('table').find('tr').as('rows')\n")),(0,s.kt)("p",null,"Internally, Cypress has made a reference to the ",(0,s.kt)("inlineCode",{parentName:"p"},"<tr>"),' collection returned as\nthe alias "rows". To reference these same "rows" later, you can use the\n',(0,s.kt)("a",{parentName:"p",href:"/api/commands/get"},(0,s.kt)("inlineCode",{parentName:"a"},"cy.get()"))," command."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"// Cypress returns the reference to the <tr>'s\n// which allows us to continue to chain commands\n// finding the 1st row.\ncy.get('@rows').first().click()\n")),(0,s.kt)("p",null,"Because we've used the ",(0,s.kt)("inlineCode",{parentName:"p"},"@")," character in ",(0,s.kt)("a",{parentName:"p",href:"/api/commands/get"},(0,s.kt)("inlineCode",{parentName:"a"},"cy.get()")),", instead\nof querying the DOM for elements, ",(0,s.kt)("a",{parentName:"p",href:"/api/commands/get"},(0,s.kt)("inlineCode",{parentName:"a"},"cy.get()"))," looks for an\nexisting alias called ",(0,s.kt)("inlineCode",{parentName:"p"},"rows")," and returns the reference (if it finds it)."),(0,s.kt)("h4",{id:"Stale-Elements"},"Stale Elements:"),(0,s.kt)("p",null,"In many single-page applications, the JavaScript re-renders parts of the DOM\nconstantly. This is why we always re-run queries when you fetch an alias, so you\nnever end up with stale elements."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<ul id="todos">\n  <li>\n    Walk the dog\n    <button class="edit">edit</button>\n  </li>\n  <li>\n    Feed the cat\n    <button class="edit">edit</button>\n  </li>\n</ul>\n')),(0,s.kt)("p",null,"Let's imagine when we click the ",(0,s.kt)("inlineCode",{parentName:"p"},".edit")," button that our ",(0,s.kt)("inlineCode",{parentName:"p"},"<li>")," is re-rendered in\nthe DOM. Instead of displaying the edit button it instead displays an\n",(0,s.kt)("inlineCode",{parentName:"p"},"<input />")," text field allowing you to edit the todo. The previous ",(0,s.kt)("inlineCode",{parentName:"p"},"<li>")," has\nbeen ",(0,s.kt)("em",{parentName:"p"},"completely")," removed from the DOM and a new ",(0,s.kt)("inlineCode",{parentName:"p"},"<li>")," is rendered in its\nplace."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"cy.get('[data-testid=\"todos\"] li').first().as('firstTodo')\n\ncy.get('@firstTodo').find('.edit').click()\n\ncy.get('@firstTodo')\n  .should('have.class', 'editing')\n  .find('input')\n  .type('Clean the kitchen')\n")),(0,s.kt)("p",null,"Every time we reference ",(0,s.kt)("inlineCode",{parentName:"p"},"@firstTodo"),", Cypress re-runs the queries leading up to\nthe alias definition."),(0,s.kt)("p",null,"In our case it would re-query the DOM using: ",(0,s.kt)("inlineCode",{parentName:"p"},"cy.get('#todos li').first()"),".\nEverything works because the new ",(0,s.kt)("inlineCode",{parentName:"p"},"<li>")," is found."),(0,s.kt)("admonition",{type:"caution"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("em",{parentName:"p"},"Usually"),", replaying previous commands will return what you expect, but not\nalways. It is recommended that you ",(0,s.kt)("strong",{parentName:"p"},"alias elements before running commands"),"."),(0,s.kt)("ul",{parentName:"admonition"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"cy.get('nav').find('header').find('[data-testid=\"user\"]').as('user').click()"),(0,s.kt)(p,{name:"check-circle",color:"green",mdxType:"Icon"})," (good)"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"cy.get('nav').find('header').find('[data-testid=\"user\"]').click().as('user')"),(0,s.kt)(p,{name:"exclamation-triangle",color:"red",mdxType:"Icon"})," (bad)"))),(0,s.kt)("h3",{id:"Intercepts"},"Intercepts"),(0,s.kt)("p",null,"Aliases can also be used with ",(0,s.kt)("a",{parentName:"p",href:"/api/commands/intercept"},"cy.intercept()"),".\nAliasing your intercepted routes enables you to:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"ensure your application makes the intended requests"),(0,s.kt)("li",{parentName:"ul"},"wait for your server to send the response"),(0,s.kt)("li",{parentName:"ul"},"access the actual request object for assertions")),(0,s.kt)(d,{src:"/img/guides/core-concepts/aliasing-routes.png",alt:"Alias commands",mdxType:"DocsImage"}),(0,s.kt)("p",null,"Here's an example of aliasing an intercepted route and waiting on it to\ncomplete."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"cy.intercept('POST', '/users', { id: 123 }).as('postUser')\n\ncy.get('form').submit()\n\ncy.wait('@postUser').then(({ request }) => {\n  expect(request.body).to.have.property('name', 'Brian')\n})\n\ncy.contains('Successfully created user: Brian')\n")),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("strong",null,"New to Cypress?"),(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("a",{parentName:"p",href:"/guides/guides/network-requests"},"We have a much more detailed and comprehensive guide on routing Network Requests."))),(0,s.kt)("h3",{id:"Requests"},"Requests"),(0,s.kt)("p",null,"Aliases can also be used with ",(0,s.kt)("a",{parentName:"p",href:"/api/commands/request"},"requests"),"."),(0,s.kt)("p",null,"Here's an example of aliasing a request and accessing its properties later."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"cy.request('https://jsonplaceholder.cypress.io/comments').as('comments')\n\n// other test code here\n\ncy.get('@comments').should((response) => {\n  if (response.status === 200) {\n      expect(response).to.have.property('duration')\n    } else {\n      // whatever you want to check here\n    }\n  })\n})\n")),(0,s.kt)("h3",{id:"Aliases-are-reset-before-each-test"},"Aliases are reset before each test"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Note:")," all aliases are reset before each test. A common user mistake is to\ncreate aliases using the ",(0,s.kt)("inlineCode",{parentName:"p"},"before")," hook. Such aliases work in the first test\nonly!"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udea8 THIS EXAMPLE DOES NOT WORK\nbefore(() => {\n  // notice this alias is created just once using \"before\" hook\n  cy.wrap('some value').as('exampleValue')\n})\n\nit('works in the first test', () => {\n  cy.get('@exampleValue').should('equal', 'some value')\n})\n\n// NOTE the second test is failing because the alias is reset\nit('does not exist in the second test', () => {\n  // there is not alias because it is created once before\n  // the first test, and is reset before the second test\n  cy.get('@exampleValue').should('equal', 'some value')\n})\n")),(0,s.kt)("p",null,"The solution is to create the aliases before each test using the ",(0,s.kt)("inlineCode",{parentName:"p"},"beforeEach"),"\nhook"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// \u2705 THE CORRECT EXAMPLE\nbeforeEach(() => {\n  // we will create a new alias before each test\n  cy.wrap('some value').as('exampleValue')\n})\n\nit('works in the first test', () => {\n  cy.get('@exampleValue').should('equal', 'some value')\n})\n\nit('works in the second test', () => {\n  cy.get('@exampleValue').should('equal', 'some value')\n})\n")),(0,s.kt)("h2",{id:"See-also"},"See also"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://glebbahmutov.com/blog/fixtures-in-custom-commands/"},"Blog: Load Fixtures from Cypress Custom Commands"),"\nexplains how to load or import fixtures to be used in the Cypress custom\ncommands.")))}h.isMDXComponent=!0}}]);